{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"build-magic \ud83d\udd28\u2728 \u00b6 An un-opinionated, general purpose automation tool. Build-magic is a command-line application for automating build, test, install, and deploy tasks. It's designed to be easy to use by both developers and DevOps engineers. Using build-magic is as simple as: > build-magic echo hello world! but can support complex build automation with multiple steps on the command-line or in a Config File. Command-line > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --cleanup \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : name : release runner : docker environment : ubuntu:latest action : cleanup commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory Build-magic can execute a batch of commands in a Config File with: > build-magic -C release.yaml Or, if the Config File is named build-magic.yaml , can be run similar to the make command with: > build-magic release Common Use Cases \u00b6 Automate building, testing, and releasing new software versions. Build and deploy new machine learning models. Automate deploying software to staging or production cloud environments. Simplify onboarding new team members by automating development environment setup and installation. Automate launching an application for local testing with the same config file used for deploying in production. Execute regression, integration, and unit tests across multiple platforms and servers. Automate dry runs of critical commands that cannot be tested on a production system. Features \u00b6 Work the way you want to work \u00b6 Developing for Linux from a Windows or MacOS laptop? Build-magic lets you build, test, and deploy your application within a Docker container, virtual machine, or on a remote machine. Build-magic will manage the environment differences for you so you can focus on the details that matter. Automate everything \u00b6 If your terminal can do it, build-magic can automate it! Build-magic is a modern alternative to automating with Makefiles and shell scripts. Build-magic config files feature an easy to use YAML syntax for executing multiple stages (targets). Build-magic actions can also apply setup and teardown behaviors for preserving container or VM state, or clean up extra files generated as part of a build process. Build-magic also gives you control over how output is displayed by providing a TTY friendly format as well a log file friendly format. Simple but powerful \u00b6 There are no looping mechanics or specialized conditional logic handlers beyond what can be done via the command-line. This might seem like a disadvantage but it makes build-magic jobs easier to debug, re-run, and replicate. What build-magic lacks in programming language-like features, it makes up for with easy of use and powerful actions. By using the cleanup action, build-magic jobs become idempotent. The persist action will preserve the state of a container or VM after execution of a job. Un-opinionated \u00b6 As much as possible, build-magic strives to setup environments and execute commands the same way, whether commands are being executed locally, remotely, in a container, or in a VM. Also, unlike similar automation tools that have builtin directives, build-magic command directives don't impart any special meaning or track state -- they are simply descriptive. This keeps things simple, and what you see in a build-magic config file or in command-line arguments is exactly what's executed. Aside from the simple syntax, build-magic doesn't care how you run commands. Runtime variables \u00b6 Build-magic config files support placeholders using a Jinja-like syntax. At runtime, dynamic values and secrets can be assigned and substituted for the placeholders, allowing for general-purpose, multi-user use cases. Simplify onboarding a new team member by automating project setup with a single build-magic config file. Cross platform \u00b6 Build-magic runs on Windows, Mac OS, and Linux. For ultimate portability, build-magic supports executing commands on a remote server via SSH, in a Docker container, or in a virtual machine via Vagrant. Build-magic config files support variable substitution so dynamic values like version numbers and credentials can be supplied at runtime and substituted into commands.","title":"Home"},{"location":"#build-magic","text":"An un-opinionated, general purpose automation tool. Build-magic is a command-line application for automating build, test, install, and deploy tasks. It's designed to be easy to use by both developers and DevOps engineers. Using build-magic is as simple as: > build-magic echo hello world! but can support complex build automation with multiple steps on the command-line or in a Config File. Command-line > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --cleanup \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Config File build-magic : - stage : name : release runner : docker environment : ubuntu:latest action : cleanup commands : - execute : ./configure CC=c99 CFLAGS=-O2 LIBS=-lposix - build : make - test : make test - execute : tar -czf myapp.tar.gz build/* - release : jfrog rt upload myapp.tar.gz my-artifactory Build-magic can execute a batch of commands in a Config File with: > build-magic -C release.yaml Or, if the Config File is named build-magic.yaml , can be run similar to the make command with: > build-magic release","title":"build-magic &#x1F528;&#x2728;"},{"location":"#common-use-cases","text":"Automate building, testing, and releasing new software versions. Build and deploy new machine learning models. Automate deploying software to staging or production cloud environments. Simplify onboarding new team members by automating development environment setup and installation. Automate launching an application for local testing with the same config file used for deploying in production. Execute regression, integration, and unit tests across multiple platforms and servers. Automate dry runs of critical commands that cannot be tested on a production system.","title":"Common Use Cases"},{"location":"#features","text":"","title":"Features"},{"location":"#work-the-way-you-want-to-work","text":"Developing for Linux from a Windows or MacOS laptop? Build-magic lets you build, test, and deploy your application within a Docker container, virtual machine, or on a remote machine. Build-magic will manage the environment differences for you so you can focus on the details that matter.","title":"Work the way you want to work"},{"location":"#automate-everything","text":"If your terminal can do it, build-magic can automate it! Build-magic is a modern alternative to automating with Makefiles and shell scripts. Build-magic config files feature an easy to use YAML syntax for executing multiple stages (targets). Build-magic actions can also apply setup and teardown behaviors for preserving container or VM state, or clean up extra files generated as part of a build process. Build-magic also gives you control over how output is displayed by providing a TTY friendly format as well a log file friendly format.","title":"Automate everything"},{"location":"#simple-but-powerful","text":"There are no looping mechanics or specialized conditional logic handlers beyond what can be done via the command-line. This might seem like a disadvantage but it makes build-magic jobs easier to debug, re-run, and replicate. What build-magic lacks in programming language-like features, it makes up for with easy of use and powerful actions. By using the cleanup action, build-magic jobs become idempotent. The persist action will preserve the state of a container or VM after execution of a job.","title":"Simple but powerful"},{"location":"#un-opinionated","text":"As much as possible, build-magic strives to setup environments and execute commands the same way, whether commands are being executed locally, remotely, in a container, or in a VM. Also, unlike similar automation tools that have builtin directives, build-magic command directives don't impart any special meaning or track state -- they are simply descriptive. This keeps things simple, and what you see in a build-magic config file or in command-line arguments is exactly what's executed. Aside from the simple syntax, build-magic doesn't care how you run commands.","title":"Un-opinionated"},{"location":"#runtime-variables","text":"Build-magic config files support placeholders using a Jinja-like syntax. At runtime, dynamic values and secrets can be assigned and substituted for the placeholders, allowing for general-purpose, multi-user use cases. Simplify onboarding a new team member by automating project setup with a single build-magic config file.","title":"Runtime variables"},{"location":"#cross-platform","text":"Build-magic runs on Windows, Mac OS, and Linux. For ultimate portability, build-magic supports executing commands on a remote server via SSH, in a Docker container, or in a virtual machine via Vagrant. Build-magic config files support variable substitution so dynamic values like version numbers and credentials can be supplied at runtime and substituted into commands.","title":"Cross platform"},{"location":"CHANGELOG/","text":"What's New \u00b6 Version 0.3.3 \u00b6 Fixed a bug where an error when parsing a YAML file was not caught and handled. Code cleanup and style enforcement with Flake8. Version 0.3.2 \u00b6 Updated dependencies to newer versions. Version 0.3.1 \u00b6 Updated dependency versions. Improved the error message when Docker or Vagrant isn't installed. Fixed a bug that caused the spinner to continue running if the environment is a Docker container that cannot be found. Improved error handling in the case a Docker container cannot be found. Added a check for if a build-magic container is already running and raises an exception if so. Added a check to make sure the provided host working directory exists for the Docker and Vagrant runners. Version 0.3.0 \u00b6 Added the --template option for generating an example Config File named build-magic_template.yaml. Added support for variable substitution in Config Files using the syntax {{ VARIABLE }} which can be substituted with myhost by using the command-line option --variable VARIABLE myhost . Added the --prompt option to interactively prompt the user for a value to substitute with --prompt VARIABLE . Fixed a bug in the cleanup action that caused directories to not be properly deleted on Windows. Fixed a bug where open default config files were not being properly closed on Windows. Fixed a bug affecting commands displayed that are too long for the terminal or end in a new line character. Fixed a bug where the spinner continued to run after a keyboard interrupt was received. Fixed a bug where using the cleanup action on Windows would cause a job to fail on startup if a file or directory raised a permission error. Fixed a bug that prevented stderr from a command executed in a Docker container from being displayed properly. Version 0.2.0 \u00b6 Added the --target and -t options to execute specific config file stages by name. Added the ability to run specific config file stages by name passed as an argument if the config file has a default name of build-magic.yaml. Added a process spinner to long-running stage start up commands. Added the sequence number and total commands to the output for each command. Removed the newline character at the end of the output displayed when in verbose mode. Changed the stage end status from COMPLETE to DONE. Version 0.1.1 \u00b6 Added the hammer and sparkles emoji to the terminal output. Suppressed the Vagrant not installed log warning. Updated requests to 2.25.1 in requirements.txt. Fixed a bug with the cleanup action that was corrupting git refs by ignoring modified files in the .git directory. Fixed a bug with terminal output that could cause a large empty gap of lines if build-magic is executed after running the clear command. Version 0.1.0 \u00b6 Initial release. \ud83c\udf89","title":"What's New"},{"location":"CHANGELOG/#whats-new","text":"","title":"What's New"},{"location":"CHANGELOG/#version-033","text":"Fixed a bug where an error when parsing a YAML file was not caught and handled. Code cleanup and style enforcement with Flake8.","title":"Version 0.3.3"},{"location":"CHANGELOG/#version-032","text":"Updated dependencies to newer versions.","title":"Version 0.3.2"},{"location":"CHANGELOG/#version-031","text":"Updated dependency versions. Improved the error message when Docker or Vagrant isn't installed. Fixed a bug that caused the spinner to continue running if the environment is a Docker container that cannot be found. Improved error handling in the case a Docker container cannot be found. Added a check for if a build-magic container is already running and raises an exception if so. Added a check to make sure the provided host working directory exists for the Docker and Vagrant runners.","title":"Version 0.3.1"},{"location":"CHANGELOG/#version-030","text":"Added the --template option for generating an example Config File named build-magic_template.yaml. Added support for variable substitution in Config Files using the syntax {{ VARIABLE }} which can be substituted with myhost by using the command-line option --variable VARIABLE myhost . Added the --prompt option to interactively prompt the user for a value to substitute with --prompt VARIABLE . Fixed a bug in the cleanup action that caused directories to not be properly deleted on Windows. Fixed a bug where open default config files were not being properly closed on Windows. Fixed a bug affecting commands displayed that are too long for the terminal or end in a new line character. Fixed a bug where the spinner continued to run after a keyboard interrupt was received. Fixed a bug where using the cleanup action on Windows would cause a job to fail on startup if a file or directory raised a permission error. Fixed a bug that prevented stderr from a command executed in a Docker container from being displayed properly.","title":"Version 0.3.0"},{"location":"CHANGELOG/#version-020","text":"Added the --target and -t options to execute specific config file stages by name. Added the ability to run specific config file stages by name passed as an argument if the config file has a default name of build-magic.yaml. Added a process spinner to long-running stage start up commands. Added the sequence number and total commands to the output for each command. Removed the newline character at the end of the output displayed when in verbose mode. Changed the stage end status from COMPLETE to DONE.","title":"Version 0.2.0"},{"location":"CHANGELOG/#version-011","text":"Added the hammer and sparkles emoji to the terminal output. Suppressed the Vagrant not installed log warning. Updated requests to 2.25.1 in requirements.txt. Fixed a bug with the cleanup action that was corrupting git refs by ignoring modified files in the .git directory. Fixed a bug with terminal output that could cause a large empty gap of lines if build-magic is executed after running the clear command.","title":"Version 0.1.1"},{"location":"CHANGELOG/#version-010","text":"Initial release. \ud83c\udf89","title":"Version 0.1.0"},{"location":"class_diagram/","text":"classDiagram CommandRunner o-- Local : Realizes CommandRunner o-- Remote : Realizes CommandRunner o-- Docker : Realizes CommandRunner o-- Vagrant : Realizes CommandRunner --|> Status : Returns StageFactory \"1\" --|> \"1..n\" Stage Stage \"1\" *-- \"1\" CommandRunner Stage \"1\" ..|> \"1\" MacroFactory : Calls Macro \"1..n\" <|-- \"1\" MacroFactory : Generates Stage \"1\" *-- \"1..n\" Macro Stage \"1\" *-- \"1..n\" Status Output \"1\" <|.. \"1\" Stage : Calls Output <|-- Basic : Inherits Output <|-- Silent : Inherits Output <|-- Tty : Inherits Action <|-- Default : Inherits Action <|-- Cleanup : Inherits Action <|-- Persist : Inherits CommandRunner o-- Action : Dynamically binds class CLI class StageFactory { -build(args) Stage -_build_parameters(List~Tuple~ parameters) dict -_build_command_runner(args) CommandRunner -_build_macros(List~str~ commands, List~str~ artifacts) List~Macro~ } class Stage { -Action _action -CommandRunner _command_runner -List~str~ _directives -List~Macro~ _macros -int _result -List~int~ _results +bool is_setup +int|str sequence +str name -_get_action_function(str method) Callable +setup() +run(bool continue_on_fail, bool verbose) int } class Engine { -bool _continue_on_fail -List~Stage~ _stages -bool _verbose +run() int } class Action { <<Abstract>> +dict add_prefix +dict add_suffix +dict mapping } class Default class Cleanup class Persist class CommandRunner { <<Abstract>> +str environment +str working_directory +str copy_from_directory +int timeout +List~str~ artifacts +dict parameters +str name -_filter_parameters(dict parameters, Tuple~str~ parameter_names) dict +cd(str|Path directory) bool +copy(str|Path src, str|Path dst) bool +provision() Status +prepare() +execute(Macro macro) Status +teardown() Status } class Local { +prepare() bool } class Remote { -_get_ssh_key() PKey +connect() SSHClient +copy(str|Path src, str|Path dst) bool +prepare() bool +execute(Macro macro) Status } class Docker { +prepare() bool +execute(Macro macro) Status } class Vagrant { +prepare() bool +execute(Macro macro) Status } class Macro { +str command +int|str sequence +str prefix +str suffix +as_string() str +as_list() List~str~ } class MacroFactory { -List~str~ commands +generate() List~Macro~ } class Status { +str stdout +str stderr +int exit_code -_validate(Any other)$ None +__repr__() str +__eq__(Any other) bool +__lt__(Any other) bool +__le__(Any other) bool +__gt__(Any other) bool +__ge__(Any other) bool } class Output { <<Abstract>> +datetime timer +start_job() +end_job() +no_job() +start_stage() +end_stage() +macro_start() +macro_status() +error() +info() +log(str message) +print_message(str message, bool is_error) None -display(str line, bool error)$ None } class Basic { +start_job() None +end_job() None +no_job() None +start_stage(str|int stage_number, str Name) None +end_stage(str|int stage_number, int status_code, str name) None +macro_start() None +macro_status(str directive, str command, int status_code) None +error(str error) None +info(str msg) None } class Tty { -Terminal _term +get_width() int +get_height() int +start_job() None +end_job() None +no_job() None +start_stage(str|int stage_number, str Name) None +end_stage(str|int stage_number, int status_code, str name) None +macro_start(str directive, str command) None +macro_status(str directive, str command, int status_code) None +error(str error) None +info(str msg) None } class Silent class EnumExt { +names() Tuple~str~ +available() Tuple~Any~ +values() Tuple~Any~ }","title":"Class diagram"},{"location":"getting_started/","text":"Getting Started \u00b6 Requirements \u00b6 Operating System: MacOS, Windows, or Linux Python 3.6+ (optional) Docker (optional) Vagrant (optional) OpenSSH (optional) The build-magic project is cross-platform and will run on all recent OS versions. If build-magic isn't installed from a binary package, Python 3.6 or greater is required. To get the most out of build-magic, it is recommended to have OpenSSH, Docker, and Vagrant installed. Installation \u00b6 Linux \u00b6 The easiest way to install build-magic for Linux is by installing from a package. Debian/Ubuntu/Mint \u00b6 Minimum compatible versions are Debian 10 (buster), Ubuntu 20.04 (focal fossa), or Mint Linux 19 (Tara). Fedora/CentOS/Red Hat \u00b6 build-magic-0.3.0rc1-0.el7.x86_64.rpm Minimum compatible versions are CentOS/RHEL 7.9 and Fedora 33. Install via pipx \u00b6 If you have Python3 installed, the recommended way to install build-magic is into an isolated environment via pipx . > pipx install build-magic Installing from PyPI \u00b6 You can install build-magic using pip with the following command: > pip install build-magic Installing from Source \u00b6 The build-magic project is written in Python. First, create a new virtual environment for development with: > python3 -m venv /path/to/new/virtual/environment Alternatively, you can create a virtual environment with conda or virtualenv . Be sure to activate your virtual environment with: > source /path/to/new/virtual/environment/bin/activate Next, navigate to the directory where you want to install build-magic and clone the repository using HTTPS with: > git clone https://github.com/cmmorrow/build-magic.git Or using SSH with: > git clone git@github.com:cmmorrow/build-magic.git Or using the GitHub CLI with: > gh repo clone cmmorrow/build-magic Getting The Most Out of build-magic With Optional Command Runners \u00b6 In addition to running commands on your machine, build-magic can also run commands in a virtual machine, a Docker container, or on a remote machine. Using Docker \u00b6 To use build-magic to run commands in a container, you will need to have Docker installed. Instructions on how to install Docker can be found here . Using A Virtual Machine \u00b6 Build-magic can execute commands in a virtual machine via Vagrant . Vagrant is a command-line tool for controlling virtual machines. Instructions on how to install Vagrant can be found here . Using a Remote Machine \u00b6 Build-magic can execute commands on a remote machine via SSH . To allow remote command execution, SSH client needs to be installed on the local machine and SSH server needs to be installed and running on the remote machine. If you're using MacOS or Linux, both SSH client and SSH server should be installed. If you are using Windows 10, SSH client and SSH server are installable features. Instructions for installing SSH on Windows 10 or Windows Server 2019 can be found here . Currently, build-magic only supports SSH connections via public/private key pairs for password-less login. Password-less login needs to be working before build-magic can make use of remote command execution. You can read more about how to configure public/private key pairs on SSH.com . Basic Usage \u00b6 You can verify build-magic is install by running the following command from a command prompt: > build-magic --verbose \"echo 'hello world'\" You should see build-magic run and output hello world","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#requirements","text":"Operating System: MacOS, Windows, or Linux Python 3.6+ (optional) Docker (optional) Vagrant (optional) OpenSSH (optional) The build-magic project is cross-platform and will run on all recent OS versions. If build-magic isn't installed from a binary package, Python 3.6 or greater is required. To get the most out of build-magic, it is recommended to have OpenSSH, Docker, and Vagrant installed.","title":"Requirements"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#linux","text":"The easiest way to install build-magic for Linux is by installing from a package.","title":"Linux"},{"location":"getting_started/#debianubuntumint","text":"Minimum compatible versions are Debian 10 (buster), Ubuntu 20.04 (focal fossa), or Mint Linux 19 (Tara).","title":"Debian/Ubuntu/Mint"},{"location":"getting_started/#fedoracentosred-hat","text":"build-magic-0.3.0rc1-0.el7.x86_64.rpm Minimum compatible versions are CentOS/RHEL 7.9 and Fedora 33.","title":"Fedora/CentOS/Red Hat"},{"location":"getting_started/#install-via-pipx","text":"If you have Python3 installed, the recommended way to install build-magic is into an isolated environment via pipx . > pipx install build-magic","title":"Install via pipx"},{"location":"getting_started/#installing-from-pypi","text":"You can install build-magic using pip with the following command: > pip install build-magic","title":"Installing from PyPI"},{"location":"getting_started/#installing-from-source","text":"The build-magic project is written in Python. First, create a new virtual environment for development with: > python3 -m venv /path/to/new/virtual/environment Alternatively, you can create a virtual environment with conda or virtualenv . Be sure to activate your virtual environment with: > source /path/to/new/virtual/environment/bin/activate Next, navigate to the directory where you want to install build-magic and clone the repository using HTTPS with: > git clone https://github.com/cmmorrow/build-magic.git Or using SSH with: > git clone git@github.com:cmmorrow/build-magic.git Or using the GitHub CLI with: > gh repo clone cmmorrow/build-magic","title":"Installing from Source"},{"location":"getting_started/#getting-the-most-out-of-build-magic-with-optional-command-runners","text":"In addition to running commands on your machine, build-magic can also run commands in a virtual machine, a Docker container, or on a remote machine.","title":"Getting The Most Out of build-magic With Optional Command Runners"},{"location":"getting_started/#using-docker","text":"To use build-magic to run commands in a container, you will need to have Docker installed. Instructions on how to install Docker can be found here .","title":"Using Docker"},{"location":"getting_started/#using-a-virtual-machine","text":"Build-magic can execute commands in a virtual machine via Vagrant . Vagrant is a command-line tool for controlling virtual machines. Instructions on how to install Vagrant can be found here .","title":"Using A Virtual Machine"},{"location":"getting_started/#using-a-remote-machine","text":"Build-magic can execute commands on a remote machine via SSH . To allow remote command execution, SSH client needs to be installed on the local machine and SSH server needs to be installed and running on the remote machine. If you're using MacOS or Linux, both SSH client and SSH server should be installed. If you are using Windows 10, SSH client and SSH server are installable features. Instructions for installing SSH on Windows 10 or Windows Server 2019 can be found here . Currently, build-magic only supports SSH connections via public/private key pairs for password-less login. Password-less login needs to be working before build-magic can make use of remote command execution. You can read more about how to configure public/private key pairs on SSH.com .","title":"Using a Remote Machine"},{"location":"getting_started/#basic-usage","text":"You can verify build-magic is install by running the following command from a command prompt: > build-magic --verbose \"echo 'hello world'\" You should see build-magic run and output hello world","title":"Basic Usage"},{"location":"user_guide/cli_usage/","text":"Using the build-magic Command-line Interface \u00b6 Synopsis \u00b6 Provide Commands \u00b6 build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] <command> build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] [--copy <copy-from>] [--continue | --stop] [-c | --command <directive command>]... [<artifact>...] Provide Config Files \u00b6 build-magic [--fancy | --plain | --quiet] [--verbose] [-t | --target <stage name>]... [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... -C | --config <config-file> build-magic [--fancy | --plain | --quiet] [--verbose] [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... all | <stage name>... | [-t | --target <stage name>]... Usage \u00b6 There are two ways to use build-magic from the command-line. Specify commands to execute from the command line \u00b6 Execute a single command where any arguments provided after valid options are interpreted as part of <command> . For example: > build-magic --verbose echo hello world Alternatively, execute a single stage with multiple commands. This form must use one or more [-c | --command <directive command>] options to specify the commands. For example: > build-magic --verbose \\ --command execute 'echo \"hello world\" > hello.txt' \\ --command execute 'cat hello.txt' In this form, any arguments provided after valid options are interpreted as one or more <artifact> . Artifact arguments are ignored unless the --copy option is used. The artifacts must exist in <copy-from> to be copied to the working directory. For example: > build-magic --copy src --command build 'make' audio.c equalizer.c effects.c Description \u00b6 --help - Prints build-magic's help text. --version - Prints the build-magic version. -r , --runner - The command runner to use for executing commands. Must be one of local , remote , vagrant or docker . The default command runner is local . -e , --environment - The environment to use for the specified command runner. The context of the environment depends on the command runner. local - The environment option is ignored. remote - The host machine to connect to in the form user@host:port . If port isn't provided, it will default to 22. vagrant - The path to the Vagrantfile to use for provisioning the Vagrant virtual machine. docker - The name of the container to use. Optionally, the container tag can be specified in the form container:tag . If --runner is defined and not equal to local , --environment is required. --name - Optional name <stage> to give the executing stage. If --name isn't provided, the default stage name is 1. --wd - The working directory build-magic will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote command runners, the working directory is on the host machine. For vagrant and docker command runners, the working directory is on the guest machine, i.e. inside the virtual machine or running container. If the copy option is provided along with <artifacts> , the <artifacts> are copied from <copy-from> to <working-directory> . -p , --parameter - Key/value pairs <p-name p-value> of optional command runner specific configurations. Can be provided multiple times. --action - Runs the specified setup and teardown action. default - Performs container and vm setup and teardown for the docker and vagrant command runners. cleanup - Deletes any new files or newly created copies of existing files after the last command is executed and before build-magic exits. persist - Only used by the vagrant and docker command runners. If specified, the virtual machine or container won't be destroyed after build-magic exits. The default action is set by default. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. --copy - Copy <artifacts> from <copy-from> to <working-directory> . --continue , --stop - Default setting is --stop . If --stop is set, build-magic will exit if a command fails (returns a non-zero exit code). If --continue is set, build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using --continue can lead to unstable behavior as failures can cascade to subsequent commands. -c , --command - A <directive command> pair to execute. The command must be wrapped in quotes for build-magic to parse it correctly. For example: --command execute \"echo 'hello world'\" . Can be provided multiple times. Specify stages and commands to execute from a Config File \u00b6 Execute multiple stages with multiple commands using a Config File. For example: > build-magic --config my_config.yaml A Config File in a different directory can also be used by providing the relative or absolute path to the config file: > build-magic --config my_project/config.yaml Multiple Config Files can be specified and they will be executed in order. > build-magic --config config1.yaml --config config2.yaml Execute a specific stage in a Config File with the --target option. If for example, a Config File has three stages named build , test , and deploy , the deploy stage can be run on it's own with: > build-magic --config my_config.yaml --target deploy Multiple targets can be specified to change the stage execution order of a Config File. Running tests before building can be accomplished with: > build-magic --config my_config.yaml --target test --target build Named stages in a Config File can also be run similar to a Makefile by specifying the stage name: > build-magic deploy However, this usage will only work if the Config File is named one of the following default filenames: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml To run all the stages in a default named Config File, use: > build-magic all Note The make like usage is more limited than using the --target option. Only a single stage can be executed by name as an argument, or all stages can be executed in order with all . Stage names also need to be a single word. Also, a Config File must have one of the default filenames mentioned above, which also means multiple Config Files cannot be used. The Config File must also be in the directory build-magic is being executed from. If a directory has more than one of the above named files in the same directory, an error is returned when running build-magic. While convenient, it's recommended to use the --target option instead for these reasons. It is also possible to use the --target option with a Config File that has a default filename without having to specify the Config File name with --config . For example: > build-magic --target test --target build Note If running build-magic from a directory that has a Config File with a default filename and another Config File is specified with the --config option, both Config Files will be executed with the Config File with the default filename running first. Description \u00b6 --help - Prints build-magic's help text. --version - Prints the build-magic version. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. -C , --config - Executes the stages in <config-file> . -t , --target - Matches the name of a stage in the specified Config File or files to execute. If <stage name> doesn't match a named stage in any of the Config Files, an error is returned. Multiple targets can be provided and each corresponding stage will be executed in the order the targets are specified. -v , --variable - A name/value pair of <var-name var-value> where the name matches a placeholder in a Config File using the syntax {{ var-name }} and the value is the value to substitute the placeholder with. --prompt - Similar to --variable but only accepts a placeholder name <prompt-name> and interactively prompts the user to input the value to be substituted. The input is hidden as to not be displayed in the shell history.","title":"Using the CLI"},{"location":"user_guide/cli_usage/#using-the-build-magic-command-line-interface","text":"","title":"Using the build-magic Command-line Interface"},{"location":"user_guide/cli_usage/#synopsis","text":"","title":"Synopsis"},{"location":"user_guide/cli_usage/#provide-commands","text":"build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] <command> build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] [--copy <copy-from>] [--continue | --stop] [-c | --command <directive command>]... [<artifact>...]","title":"Provide Commands"},{"location":"user_guide/cli_usage/#provide-config-files","text":"build-magic [--fancy | --plain | --quiet] [--verbose] [-t | --target <stage name>]... [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... -C | --config <config-file> build-magic [--fancy | --plain | --quiet] [--verbose] [-v | --variable <var-name var-value>]... [--prompt <prompt-name>]... all | <stage name>... | [-t | --target <stage name>]...","title":"Provide Config Files"},{"location":"user_guide/cli_usage/#usage","text":"There are two ways to use build-magic from the command-line.","title":"Usage"},{"location":"user_guide/cli_usage/#specify-commands-to-execute-from-the-command-line","text":"Execute a single command where any arguments provided after valid options are interpreted as part of <command> . For example: > build-magic --verbose echo hello world Alternatively, execute a single stage with multiple commands. This form must use one or more [-c | --command <directive command>] options to specify the commands. For example: > build-magic --verbose \\ --command execute 'echo \"hello world\" > hello.txt' \\ --command execute 'cat hello.txt' In this form, any arguments provided after valid options are interpreted as one or more <artifact> . Artifact arguments are ignored unless the --copy option is used. The artifacts must exist in <copy-from> to be copied to the working directory. For example: > build-magic --copy src --command build 'make' audio.c equalizer.c effects.c","title":"Specify commands to execute from the command line"},{"location":"user_guide/cli_usage/#description","text":"--help - Prints build-magic's help text. --version - Prints the build-magic version. -r , --runner - The command runner to use for executing commands. Must be one of local , remote , vagrant or docker . The default command runner is local . -e , --environment - The environment to use for the specified command runner. The context of the environment depends on the command runner. local - The environment option is ignored. remote - The host machine to connect to in the form user@host:port . If port isn't provided, it will default to 22. vagrant - The path to the Vagrantfile to use for provisioning the Vagrant virtual machine. docker - The name of the container to use. Optionally, the container tag can be specified in the form container:tag . If --runner is defined and not equal to local , --environment is required. --name - Optional name <stage> to give the executing stage. If --name isn't provided, the default stage name is 1. --wd - The working directory build-magic will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote command runners, the working directory is on the host machine. For vagrant and docker command runners, the working directory is on the guest machine, i.e. inside the virtual machine or running container. If the copy option is provided along with <artifacts> , the <artifacts> are copied from <copy-from> to <working-directory> . -p , --parameter - Key/value pairs <p-name p-value> of optional command runner specific configurations. Can be provided multiple times. --action - Runs the specified setup and teardown action. default - Performs container and vm setup and teardown for the docker and vagrant command runners. cleanup - Deletes any new files or newly created copies of existing files after the last command is executed and before build-magic exits. persist - Only used by the vagrant and docker command runners. If specified, the virtual machine or container won't be destroyed after build-magic exits. The default action is set by default. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. --copy - Copy <artifacts> from <copy-from> to <working-directory> . --continue , --stop - Default setting is --stop . If --stop is set, build-magic will exit if a command fails (returns a non-zero exit code). If --continue is set, build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using --continue can lead to unstable behavior as failures can cascade to subsequent commands. -c , --command - A <directive command> pair to execute. The command must be wrapped in quotes for build-magic to parse it correctly. For example: --command execute \"echo 'hello world'\" . Can be provided multiple times.","title":"Description"},{"location":"user_guide/cli_usage/#specify-stages-and-commands-to-execute-from-a-config-file","text":"Execute multiple stages with multiple commands using a Config File. For example: > build-magic --config my_config.yaml A Config File in a different directory can also be used by providing the relative or absolute path to the config file: > build-magic --config my_project/config.yaml Multiple Config Files can be specified and they will be executed in order. > build-magic --config config1.yaml --config config2.yaml Execute a specific stage in a Config File with the --target option. If for example, a Config File has three stages named build , test , and deploy , the deploy stage can be run on it's own with: > build-magic --config my_config.yaml --target deploy Multiple targets can be specified to change the stage execution order of a Config File. Running tests before building can be accomplished with: > build-magic --config my_config.yaml --target test --target build Named stages in a Config File can also be run similar to a Makefile by specifying the stage name: > build-magic deploy However, this usage will only work if the Config File is named one of the following default filenames: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml To run all the stages in a default named Config File, use: > build-magic all Note The make like usage is more limited than using the --target option. Only a single stage can be executed by name as an argument, or all stages can be executed in order with all . Stage names also need to be a single word. Also, a Config File must have one of the default filenames mentioned above, which also means multiple Config Files cannot be used. The Config File must also be in the directory build-magic is being executed from. If a directory has more than one of the above named files in the same directory, an error is returned when running build-magic. While convenient, it's recommended to use the --target option instead for these reasons. It is also possible to use the --target option with a Config File that has a default filename without having to specify the Config File name with --config . For example: > build-magic --target test --target build Note If running build-magic from a directory that has a Config File with a default filename and another Config File is specified with the --config option, both Config Files will be executed with the Config File with the default filename running first.","title":"Specify stages and commands to execute from a Config File"},{"location":"user_guide/cli_usage/#description_1","text":"--help - Prints build-magic's help text. --version - Prints the build-magic version. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. -C , --config - Executes the stages in <config-file> . -t , --target - Matches the name of a stage in the specified Config File or files to execute. If <stage name> doesn't match a named stage in any of the Config Files, an error is returned. Multiple targets can be provided and each corresponding stage will be executed in the order the targets are specified. -v , --variable - A name/value pair of <var-name var-value> where the name matches a placeholder in a Config File using the syntax {{ var-name }} and the value is the value to substitute the placeholder with. --prompt - Similar to --variable but only accepts a placeholder name <prompt-name> and interactively prompts the user to input the value to be substituted. The input is hidden as to not be displayed in the shell history.","title":"Description"},{"location":"user_guide/config_usage/","text":"Defining build-magic Config Files \u00b6 Synopsis \u00b6 Build-magic supports executing multiple stages as static, repeatable jobs with a Config File. A build-magic Config File is a YAML file with the following structure: build-magic : - stage : name : Build Project runner : docker environment : centos:7 working directory : /home/myproject parameters : - bind : /home/myproject commands : - execute : configure - build : make - stage : name : Run tests runner : docker environment : centos:7 working directory : /home/myproject parameters : - bind : /home/myproject commands : - execute : service start mydb - test : make test - execute : service stop mydb - stage : name : Package CentOS runner : docker environment : centos:7 working directory : /home/myproject parameters : - bind : /home/myproject commands : - build : make rpm - release : jfrog rt upload \"build/RPMS/x86_64/(*).rpm\" my-artifactory Description \u00b6 build-magic - Each build-magic Config File must start with build-magic on the first line. The type of the build-magic property is an array of stage properties. The build-magic property must define at least one stage . stage - Each stage is an object that defines the same properties as the CLI. The only property of stage that's required is commands . name - Optional name to give the executing stage . If name isn't provided, the default stage name is 1, and each subsequent stage name is incremented by 1. runner - The command runner to use for executing commands. The value must be one of local , remote , vagrant or docker . The default command runner is local . environment - The environment to use for the specified command runner. If the runner property is defined and not equal to local , the environment property is required. action The setup and teardown action to use. The value must be one of default , cleanup , or persist . The default action is default . continue on fail - If true , build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using continue can lead to unstable behavior as failures can cascade to subsequent commands. copy from directory - The path to copy artifacts from. If defined, build-magic will copy the array of items in artifacts to working directory . working directory - The working directory the stage will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote runner , the working directory is on the host machine. For the vagrant and docker runner , the working directory is on the guest machine, i.e. inside the virtual machine or running container. artifacts - Files to be copied from the copy from directory to the working directory . Artifacts are ignored unless the copy from directory option is set. The artifacts must exist in copy from directory path to be copied to the working directory. parameters - A list of key/value pairs of command runner specific configurations. commands - A list of key/value pairs, where the key is a directive and the value is the command to execute.","title":"Defining Config Files"},{"location":"user_guide/config_usage/#defining-build-magic-config-files","text":"","title":"Defining build-magic Config Files"},{"location":"user_guide/config_usage/#synopsis","text":"Build-magic supports executing multiple stages as static, repeatable jobs with a Config File. A build-magic Config File is a YAML file with the following structure: build-magic : - stage : name : Build Project runner : docker environment : centos:7 working directory : /home/myproject parameters : - bind : /home/myproject commands : - execute : configure - build : make - stage : name : Run tests runner : docker environment : centos:7 working directory : /home/myproject parameters : - bind : /home/myproject commands : - execute : service start mydb - test : make test - execute : service stop mydb - stage : name : Package CentOS runner : docker environment : centos:7 working directory : /home/myproject parameters : - bind : /home/myproject commands : - build : make rpm - release : jfrog rt upload \"build/RPMS/x86_64/(*).rpm\" my-artifactory","title":"Synopsis"},{"location":"user_guide/config_usage/#description","text":"build-magic - Each build-magic Config File must start with build-magic on the first line. The type of the build-magic property is an array of stage properties. The build-magic property must define at least one stage . stage - Each stage is an object that defines the same properties as the CLI. The only property of stage that's required is commands . name - Optional name to give the executing stage . If name isn't provided, the default stage name is 1, and each subsequent stage name is incremented by 1. runner - The command runner to use for executing commands. The value must be one of local , remote , vagrant or docker . The default command runner is local . environment - The environment to use for the specified command runner. If the runner property is defined and not equal to local , the environment property is required. action The setup and teardown action to use. The value must be one of default , cleanup , or persist . The default action is default . continue on fail - If true , build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using continue can lead to unstable behavior as failures can cascade to subsequent commands. copy from directory - The path to copy artifacts from. If defined, build-magic will copy the array of items in artifacts to working directory . working directory - The working directory the stage will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote runner , the working directory is on the host machine. For the vagrant and docker runner , the working directory is on the guest machine, i.e. inside the virtual machine or running container. artifacts - Files to be copied from the copy from directory to the working directory . Artifacts are ignored unless the copy from directory option is set. The artifacts must exist in copy from directory path to be copied to the working directory. parameters - A list of key/value pairs of command runner specific configurations. commands - A list of key/value pairs, where the key is a directive and the value is the command to execute.","title":"Description"},{"location":"user_guide/core_concepts/","text":"Core Concepts \u00b6 To get the most out of build-magic, you should become familiar with build-magic's core concepts: Commands Directives Command Runners Output Formats Working Directory Stages Config File Targets Variables Job Actions Parameters Many of these terms will look familiar if you've used Ansible, Jenkins or GitHub Actions, but the meaning of these terms can be quite different for build-magic. Commands \u00b6 Build-magic's primary focus is executing Commands. A Command is a valid command-line interface command that can be executed in a single line. Commands are executed by build-magic using the default shell of the machine the Command is executing on. Each Command that build-magic executes returns stdout, stderr, and an exit code. If a Command returns an exit code other than 0, build-magic will by default stop execution and display any error message from stderr. There are two ways to execute Commands with build-magic. The simplest way is to execute a single command as an argument to the build-magic command: > build-magic make clean In this case, build-magic simply executes the make clean Command in the current directory. Note When using a command that has multiple arguments or makes use of shell operators such as redirection > or piping | , It will be necessary to wrap the command in single quotes so that the shell doesn't try to interpret the operator. Build-magic can also execute multiple commands with the --command option in the order they are provided: > build-magic \\ --command execute 'tar -czf myfiles.tar.gz file1.txt file2.txt' \\ --command execute 'rm file1.txt file2.txt' Note that the word \"execute\" is used before the commands. This is a Directive and is described below. Each command is also surrounded in quotes, otherwise build-magic gets confused and thinks you are trying to pass additional arguments. The build-magic Config File syntax is similar but does not require quotes around the command: commands : - execute : tar -czf myfiles.tar.gz file1.txt file2.txt - execute : rm file1.txt file2.txt Directives \u00b6 Directives describe the type of Command being executed. All Commands that build-magic executes must have a Directive associated with them. Directives don't impart any special meaning to build-magic and are simply used to describe the command. Valid Directives that build-magic understands are: execute build test install release deploy If only a single command is passed to build-magic on the command-line without a Directive, the execute Directive is used by default. Command Runners \u00b6 Build-magic can execute Commands on the local machine, in a container, in a virtual machine, or on a remote machine. You tell build-magic how you want to execute the Commands by specify a Command Runner with the --runner option. Valid Command Runners are: local docker vagrant remote By default, the local Command Runner is used if the --runner option isn't provided. All Command Runners except for the local Command Runner must also provide the --environment option. The environment depends on the Command Runner being used: docker : The name of the Docker container - ubuntu:latest vagrant : The path to the Vagrantfile - ./Vagrantfile remote : The username and hostname of the remote machine to connect to - user@myhost Example: Command-line > build-magic --runner docker --environment ubuntu:latest make Config File build-magic : - stage : runner : docker environment : ubuntu:latest commands : - execute : make Output Formats \u00b6 Build-magic reports it's progress and status to stdout on a terminal. There are three different output format based on your preference and use case: fancy : Nicely formatted text output plain : Log friendly text output quiet : No output The default Output Format is fancy which is useful when using build-magic from a TTY (terminal) application. The plain Output Format is useful if build-magic is being used from a CI/CD tool or piped to a log file where a log-like output is preferred. Output Formats can only be set as a command-line option. Working Directory \u00b6 The Working Directory is the path that build-magic operates from. Non-absolute paths in commands that build-magic executes are relative to the Working Directory. The default Working Directory is the current directory. The Working Directory can be set from the command-line with the --wd /home/user command or in a build-magic Config File with working directory: /home/user . Stages \u00b6 A Stage is a collection of Commands. When you use build-magic from the command-line, all the Commands are gathered into a single stage and executed as a single collection. Build-magic can execute multiple Stages, but only by using a Config File. Config File \u00b6 A build-magic Config File is a YAML file that describes the Stages and Commands to run, and how to run them. The Config File consists of a list of Stages to be executed in order. Multiple Config Files can be provided, in which case the Stages are executed in the order they are provided in each Config File. Specific stages to execute can be selected from the command line using Targets which are described below. Targets \u00b6 A Target is a Stage name that can be used to run the corresponding Stage regardless of the Stage order in a Config file. Multiple Targets can be specified to reorder Stages at runtime. Targets can be used to filter the Stages to execute. For example, assume you have the Config File below named build-magic.yaml : build-magic : - stage : name : unittests commands : - test : pytest - stage : name : documentation action : cleanup commands : - build : mkdocs build - deploy : mkdocs gh-deploy - stage : name : package action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* To only run the unittests stage in this Config File, use the below command: > build-magic -t unittests or if the stage name is a single word, the command can be shortened to: > build-magic unittests To run just the unittests and documentation stages, use: > build-magic -t unittests -t documentation or: > build-magic unittests documentation To swap the order of the documentation and package stages, use: > build-magic unittests package documentation All stages in the Config File can be run with: build-magic all Variables \u00b6 Variables are values that are substituted for placeholders in a Config File. Variables values and the corresponding placeholder name are specified at runtime as command-line arguments. The placeholders use a Jinja-like syntax of surrounding the placeholder name in {{ }} . The following Config File container placeholders intended for Variable substitution: build-magic : - stage : name : package runner : docker environment : ubuntu:latest commands : # Build the package - build : rpmbuild -bb $HOME/rpmbuild/SPECS/app{{ version }}.spec # Install and test the package - install : dnf install -y $HOME/rpmbuild/RPMS/noarch/app{{ version }}.rpm # Upload the package - release : scp app{{ version }}.rpm {{ user }}:{{ password }}@{{ host }} This Config File can be re-used by different users to release new versions of the app RPM package. The Variables can be assigned at runtime with the following command as an example: > build-magic -t package \\ --variable version 3 .14.15 \\ --variable host myserver \\ --variable user myuser \\ --prompt password The --variable option consists of the placeholder name followed by the value. The --prompt option will interactively prompt the user for input. This is the recommended way for providing secrets that shouldn't appear in the shell history. Note The --prompt option only works when using a TTY (terminal) interactively and will cause build-magic to hang if executed from a script. Job \u00b6 A Job is a collection of all the Stages that build-magic is going to execute. If more than one Config File is provided, the Job consists of every Stage from each Config File. Actions \u00b6 Actions can be used to modify build-magic's default behavior by adding setup and teardown behavior to a Stage. Build-magic's Actions are: default: Start up and destroy the virtual machine or container when the docker or vagrant Command Runner is used by the Stage. No setup or teardown is performed for the local or remote Command Runners. persist: Don't destroy the virtual machine or container used by the Stage. Useful for debugging. cleanup: Delete any files created by a Stage. Parameters \u00b6 Parameters are optional configurations that are specific to a particular Command Runner. Command Runner Parameter Description remote keytype The SSH key type (dsa, rsa, ecdsa, ed25519) remote keypath The path to the SSH private key remote keypass The private key passphrase if set vagrant hostwd The working directory of the host (local machine) vagrant bind The vm directory that is bound to the host docker hostwd The working directory of the host (local machine) docker bind A bind path on the container to the hostwd","title":"Core Concepts"},{"location":"user_guide/core_concepts/#core-concepts","text":"To get the most out of build-magic, you should become familiar with build-magic's core concepts: Commands Directives Command Runners Output Formats Working Directory Stages Config File Targets Variables Job Actions Parameters Many of these terms will look familiar if you've used Ansible, Jenkins or GitHub Actions, but the meaning of these terms can be quite different for build-magic.","title":"Core Concepts"},{"location":"user_guide/core_concepts/#commands","text":"Build-magic's primary focus is executing Commands. A Command is a valid command-line interface command that can be executed in a single line. Commands are executed by build-magic using the default shell of the machine the Command is executing on. Each Command that build-magic executes returns stdout, stderr, and an exit code. If a Command returns an exit code other than 0, build-magic will by default stop execution and display any error message from stderr. There are two ways to execute Commands with build-magic. The simplest way is to execute a single command as an argument to the build-magic command: > build-magic make clean In this case, build-magic simply executes the make clean Command in the current directory. Note When using a command that has multiple arguments or makes use of shell operators such as redirection > or piping | , It will be necessary to wrap the command in single quotes so that the shell doesn't try to interpret the operator. Build-magic can also execute multiple commands with the --command option in the order they are provided: > build-magic \\ --command execute 'tar -czf myfiles.tar.gz file1.txt file2.txt' \\ --command execute 'rm file1.txt file2.txt' Note that the word \"execute\" is used before the commands. This is a Directive and is described below. Each command is also surrounded in quotes, otherwise build-magic gets confused and thinks you are trying to pass additional arguments. The build-magic Config File syntax is similar but does not require quotes around the command: commands : - execute : tar -czf myfiles.tar.gz file1.txt file2.txt - execute : rm file1.txt file2.txt","title":"Commands"},{"location":"user_guide/core_concepts/#directives","text":"Directives describe the type of Command being executed. All Commands that build-magic executes must have a Directive associated with them. Directives don't impart any special meaning to build-magic and are simply used to describe the command. Valid Directives that build-magic understands are: execute build test install release deploy If only a single command is passed to build-magic on the command-line without a Directive, the execute Directive is used by default.","title":"Directives"},{"location":"user_guide/core_concepts/#command-runners","text":"Build-magic can execute Commands on the local machine, in a container, in a virtual machine, or on a remote machine. You tell build-magic how you want to execute the Commands by specify a Command Runner with the --runner option. Valid Command Runners are: local docker vagrant remote By default, the local Command Runner is used if the --runner option isn't provided. All Command Runners except for the local Command Runner must also provide the --environment option. The environment depends on the Command Runner being used: docker : The name of the Docker container - ubuntu:latest vagrant : The path to the Vagrantfile - ./Vagrantfile remote : The username and hostname of the remote machine to connect to - user@myhost Example: Command-line > build-magic --runner docker --environment ubuntu:latest make Config File build-magic : - stage : runner : docker environment : ubuntu:latest commands : - execute : make","title":"Command Runners"},{"location":"user_guide/core_concepts/#output-formats","text":"Build-magic reports it's progress and status to stdout on a terminal. There are three different output format based on your preference and use case: fancy : Nicely formatted text output plain : Log friendly text output quiet : No output The default Output Format is fancy which is useful when using build-magic from a TTY (terminal) application. The plain Output Format is useful if build-magic is being used from a CI/CD tool or piped to a log file where a log-like output is preferred. Output Formats can only be set as a command-line option.","title":"Output Formats"},{"location":"user_guide/core_concepts/#working-directory","text":"The Working Directory is the path that build-magic operates from. Non-absolute paths in commands that build-magic executes are relative to the Working Directory. The default Working Directory is the current directory. The Working Directory can be set from the command-line with the --wd /home/user command or in a build-magic Config File with working directory: /home/user .","title":"Working Directory"},{"location":"user_guide/core_concepts/#stages","text":"A Stage is a collection of Commands. When you use build-magic from the command-line, all the Commands are gathered into a single stage and executed as a single collection. Build-magic can execute multiple Stages, but only by using a Config File.","title":"Stages"},{"location":"user_guide/core_concepts/#config-file","text":"A build-magic Config File is a YAML file that describes the Stages and Commands to run, and how to run them. The Config File consists of a list of Stages to be executed in order. Multiple Config Files can be provided, in which case the Stages are executed in the order they are provided in each Config File. Specific stages to execute can be selected from the command line using Targets which are described below.","title":"Config File"},{"location":"user_guide/core_concepts/#targets","text":"A Target is a Stage name that can be used to run the corresponding Stage regardless of the Stage order in a Config file. Multiple Targets can be specified to reorder Stages at runtime. Targets can be used to filter the Stages to execute. For example, assume you have the Config File below named build-magic.yaml : build-magic : - stage : name : unittests commands : - test : pytest - stage : name : documentation action : cleanup commands : - build : mkdocs build - deploy : mkdocs gh-deploy - stage : name : package action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* To only run the unittests stage in this Config File, use the below command: > build-magic -t unittests or if the stage name is a single word, the command can be shortened to: > build-magic unittests To run just the unittests and documentation stages, use: > build-magic -t unittests -t documentation or: > build-magic unittests documentation To swap the order of the documentation and package stages, use: > build-magic unittests package documentation All stages in the Config File can be run with: build-magic all","title":"Targets"},{"location":"user_guide/core_concepts/#variables","text":"Variables are values that are substituted for placeholders in a Config File. Variables values and the corresponding placeholder name are specified at runtime as command-line arguments. The placeholders use a Jinja-like syntax of surrounding the placeholder name in {{ }} . The following Config File container placeholders intended for Variable substitution: build-magic : - stage : name : package runner : docker environment : ubuntu:latest commands : # Build the package - build : rpmbuild -bb $HOME/rpmbuild/SPECS/app{{ version }}.spec # Install and test the package - install : dnf install -y $HOME/rpmbuild/RPMS/noarch/app{{ version }}.rpm # Upload the package - release : scp app{{ version }}.rpm {{ user }}:{{ password }}@{{ host }} This Config File can be re-used by different users to release new versions of the app RPM package. The Variables can be assigned at runtime with the following command as an example: > build-magic -t package \\ --variable version 3 .14.15 \\ --variable host myserver \\ --variable user myuser \\ --prompt password The --variable option consists of the placeholder name followed by the value. The --prompt option will interactively prompt the user for input. This is the recommended way for providing secrets that shouldn't appear in the shell history. Note The --prompt option only works when using a TTY (terminal) interactively and will cause build-magic to hang if executed from a script.","title":"Variables"},{"location":"user_guide/core_concepts/#job","text":"A Job is a collection of all the Stages that build-magic is going to execute. If more than one Config File is provided, the Job consists of every Stage from each Config File.","title":"Job"},{"location":"user_guide/core_concepts/#actions","text":"Actions can be used to modify build-magic's default behavior by adding setup and teardown behavior to a Stage. Build-magic's Actions are: default: Start up and destroy the virtual machine or container when the docker or vagrant Command Runner is used by the Stage. No setup or teardown is performed for the local or remote Command Runners. persist: Don't destroy the virtual machine or container used by the Stage. Useful for debugging. cleanup: Delete any files created by a Stage.","title":"Actions"},{"location":"user_guide/core_concepts/#parameters","text":"Parameters are optional configurations that are specific to a particular Command Runner. Command Runner Parameter Description remote keytype The SSH key type (dsa, rsa, ecdsa, ed25519) remote keypath The path to the SSH private key remote keypass The private key passphrase if set vagrant hostwd The working directory of the host (local machine) vagrant bind The vm directory that is bound to the host docker hostwd The working directory of the host (local machine) docker bind A bind path on the container to the hostwd","title":"Parameters"},{"location":"user_guide/runners/docker_usage/","text":"Using the Docker Command Runner \u00b6 The docker Command Runner executes commands in a container. Build-magic will start a new container named build-magic using the image specified by --environment . The container will start detached from the build-magic sub-process, use a pseudo TTY, and override the container entrypoint to /bin/sh . Note Build-magic only supports Linux-based containers with the docker Command Runner. Windows-based container will fail to launch. Running Shell Commands \u00b6 The docker Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ 'echo $TERM' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : 'echo $TERM' Setting the Working Directory \u00b6 When using the docker Command Runner, the Working Directory option --wd refers to the Working Directory within the container. Build-magic mounts a local directory, referred to as the Host Working Directory, to a Bind Directory in the container. The Bind Directory in the container might or might not be the same as the Working Directory. By default, the Host Working Directory is the current directory build-magic is executed from, but can be changed with --parameter hostwd . Command-line > build-magic -r docker -e alpine --parameter hostwd /home/myproject make Config File build-magic : - stage : runner : docker environment : alpine parameters : - hostwd : /home/myproject commands : - execute : make The Bind Directory and Working Directory both default to /build-magic in the container. The Bind Directory can be changed with --parameter bind . Command-line > build-magic -r docker -e alpine --parameter bind /app --wd /app make Config File build-magic : - stage : runner : docker environment : alpine working directory : /app parameters : - bind /app commands : make Just as with every other Command Runner, the Working Directory can be changed with the --wd option. Copying Files Into the Container \u00b6 By establishing a mount, all files in Host Working Directory are available from Bind Directory in the container. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Docker has some overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --copy /home/myproject \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : docker environment : alpine:latest copy from directory : /home/myproject working directory : /app artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make Instead of copying individual files to the Working Directory, an entire directory can be used by the container by setting the Host Working Directory, Bind Directory, and Working Directory: Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --parameter hostwd /home/myproject \\ --parameter bind /app \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' Config File build-magic : - stage : runner : docker environment : alpine:latest parameters : - hostwd : /home/myproject - bind : /app working directory : /app commands : - install : apk add gcc - build : make Cleaning Up New Files \u00b6 Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the Host Working Directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If the Working Directory is different from the Bind Directory, all files will be lost when the build-magic container is destroyed when build-magic exits. However, if the Working Directory is also the Bind Directory, any newly created files in the Host Working Directory will be deleted. The exception is for files that are copied to the Host Working Directory from a directory specified with the --copy option. Since these files are copied before the Stage starts executing Commands, they will not be cleaned up when the Stage ends. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -r docker \\ -e alpine:latest \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : docker environment : alpine:latest action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. Debugging the build-magic Container \u00b6 If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner docker \\ --environment alpine:latest \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : docker environment : alpine:latest action : persist commands : - execute : cp The command cp will fail because it doesn't have any arguments. The container will continue to run and can be seen with: > docker ps all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7fa0295c9d93 alpine:latest \"sh\" 36 seconds ago Up 34 seconds build-magic The container can be inspected by running a shell on the container with: > docker exec -it build-magic /bin/sh When finished, exit the container with exit . The container can then be stopped and destroyed with: > docker stop build-magic > docker rm build-magic Until the build-magic container is stopped and destroyed, build-magic won't be able to start a new container.","title":"Using the Docker Runner"},{"location":"user_guide/runners/docker_usage/#using-the-docker-command-runner","text":"The docker Command Runner executes commands in a container. Build-magic will start a new container named build-magic using the image specified by --environment . The container will start detached from the build-magic sub-process, use a pseudo TTY, and override the container entrypoint to /bin/sh . Note Build-magic only supports Linux-based containers with the docker Command Runner. Windows-based container will fail to launch.","title":"Using the Docker Command Runner"},{"location":"user_guide/runners/docker_usage/#running-shell-commands","text":"The docker Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ 'echo $TERM' Config File build-magic : - stage : runner : docker environment : alpine:latest commands : - execute : 'echo $TERM'","title":"Running Shell Commands"},{"location":"user_guide/runners/docker_usage/#setting-the-working-directory","text":"When using the docker Command Runner, the Working Directory option --wd refers to the Working Directory within the container. Build-magic mounts a local directory, referred to as the Host Working Directory, to a Bind Directory in the container. The Bind Directory in the container might or might not be the same as the Working Directory. By default, the Host Working Directory is the current directory build-magic is executed from, but can be changed with --parameter hostwd . Command-line > build-magic -r docker -e alpine --parameter hostwd /home/myproject make Config File build-magic : - stage : runner : docker environment : alpine parameters : - hostwd : /home/myproject commands : - execute : make The Bind Directory and Working Directory both default to /build-magic in the container. The Bind Directory can be changed with --parameter bind . Command-line > build-magic -r docker -e alpine --parameter bind /app --wd /app make Config File build-magic : - stage : runner : docker environment : alpine working directory : /app parameters : - bind /app commands : make Just as with every other Command Runner, the Working Directory can be changed with the --wd option.","title":"Setting the Working Directory"},{"location":"user_guide/runners/docker_usage/#copying-files-into-the-container","text":"By establishing a mount, all files in Host Working Directory are available from Bind Directory in the container. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Docker has some overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --copy /home/myproject \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : docker environment : alpine:latest copy from directory : /home/myproject working directory : /app artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make Instead of copying individual files to the Working Directory, an entire directory can be used by the container by setting the Host Working Directory, Bind Directory, and Working Directory: Command-line > build-magic \\ --runner docker \\ --environment alpine:latest \\ --parameter hostwd /home/myproject \\ --parameter bind /app \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' Config File build-magic : - stage : runner : docker environment : alpine:latest parameters : - hostwd : /home/myproject - bind : /app working directory : /app commands : - install : apk add gcc - build : make","title":"Copying Files Into the Container"},{"location":"user_guide/runners/docker_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the Host Working Directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If the Working Directory is different from the Bind Directory, all files will be lost when the build-magic container is destroyed when build-magic exits. However, if the Working Directory is also the Bind Directory, any newly created files in the Host Working Directory will be deleted. The exception is for files that are copied to the Host Working Directory from a directory specified with the --copy option. Since these files are copied before the Stage starts executing Commands, they will not be cleaned up when the Stage ends. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -r docker \\ -e alpine:latest \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : docker environment : alpine:latest action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/docker_usage/#debugging-the-build-magic-container","text":"If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner docker \\ --environment alpine:latest \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : docker environment : alpine:latest action : persist commands : - execute : cp The command cp will fail because it doesn't have any arguments. The container will continue to run and can be seen with: > docker ps all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7fa0295c9d93 alpine:latest \"sh\" 36 seconds ago Up 34 seconds build-magic The container can be inspected by running a shell on the container with: > docker exec -it build-magic /bin/sh When finished, exit the container with exit . The container can then be stopped and destroyed with: > docker stop build-magic > docker rm build-magic Until the build-magic container is stopped and destroyed, build-magic won't be able to start a new container.","title":"Debugging the build-magic Container"},{"location":"user_guide/runners/local_usage/","text":"Using the Local Command Runner \u00b6 The local Command Runner executes commands on the host machine where build-magic is running. This means build-magic can only run commands that work on the host machine or shell where build-magic is running. Running Shell Commands \u00b6 The local Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt > build-magic --verbose 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose 'echo $SHELL' Setting the Working Directory \u00b6 The Working Directory is the path that build-magic operates from. By default, the Working Directory is the current directory of the shell when build-magic is executed. On Linux and MacOS, this directory is the value of $PWD or pwd on Windows. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --wd ~/myproject make Config File build-magic : - stage : working directory : ~/myproject commands : - execute : make Cleaning Up New Files \u00b6 Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : action : cleanup commands : build : python setup.py sdist bdist_wheel --universal release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Using the Local Runner"},{"location":"user_guide/runners/local_usage/#using-the-local-command-runner","text":"The local Command Runner executes commands on the host machine where build-magic is running. This means build-magic can only run commands that work on the host machine or shell where build-magic is running.","title":"Using the Local Command Runner"},{"location":"user_guide/runners/local_usage/#running-shell-commands","text":"The local Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt > build-magic --verbose 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose 'echo $SHELL'","title":"Running Shell Commands"},{"location":"user_guide/runners/local_usage/#setting-the-working-directory","text":"The Working Directory is the path that build-magic operates from. By default, the Working Directory is the current directory of the shell when build-magic is executed. On Linux and MacOS, this directory is the value of $PWD or pwd on Windows. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --wd ~/myproject make Config File build-magic : - stage : working directory : ~/myproject commands : - execute : make","title":"Setting the Working Directory"},{"location":"user_guide/runners/local_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : action : cleanup commands : build : python setup.py sdist bdist_wheel --universal release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/remote_usage/","text":"Using the Remote Command Runner \u00b6 The remote Command Runner executes commands on a remote machine. To execute commands remotely, SSH needs to be installed on the host machine and configured using a public/private key pair. This way, build-magic can execute commands without prompting the user for a password. Note To connect to or from a Windows 10 machine, OpenSSH needs to be installed on the Windows machine. Build-magic isn't compatible with other Windows SSH implementations or PuTTY .ppk files. You can find instructions on installing OpenSSH for Windows 10 here . To connect to a remote machine, the --environment option should include the user and hostname of the machine to connect to, for example: Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo hello world Optionally, the port can also be given. By default, the port SSH will use is 22. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost:2222 \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost:2222 commands : - execute : echo hello world Running Shell Commands \u00b6 The remote Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ 'ps -ef | grep python' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : ps -ef | grep python Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose -r remote -e user@myhost 'echo $SHELL' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : 'echo $SHELL' Setting the Working Directory \u00b6 The Working Directory is the path that build-magic operates from. By default, the Working Directory is the home directory of user used for logging into the remote machine. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --runner remote --environment user@myhost --wd ~/myproject make Config File build-magic : - stage : runner : remote environment : user@myhost working directory : ~/myproject commands : - execute : make Copying Files To The Remote Machine \u00b6 Individual files can be copied to the remote machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner remote \\ --environment user@myhost \\ --copy /home/myproject \\ --command execute ./configure \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : remote environment : user@myhost copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - execute : ./configure - execute : make Cleaning Up New Files \u00b6 Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files on the remote machine with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory on the remote machine before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ --runner remote \\ --environment user@myhost \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : remote environment : user@myhost action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. If using the --copy option to copy files to the working directory on the remote machine, these files are deleted along with any new files created during the Stage. Working with Public/Private Keypairs \u00b6 The remote Command Runner uses SSH public/private keypairs to connect to remote machines and execute commands. By default, build-magic looks for the private key at ~/.ssh/id_rsa . The path to the private key can be specified with --parameter keypath : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keypath ~/.ssh/keys/id_rsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : - keypath : ~/.ssh/keys/id_rsa commands : - execute : echo hello world Build-magic supports several different SSH key types: rsa dsa ecdsa ed25519 The SSH key type can be specified with --parameter keytype : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : - keytype : ecdsa - keypath : ~/.ssh/id_ecdsa commands : - execute : echo hello world To use a private key protected by a passphrase, use --parameter keypass : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --parameter keypass secret \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : - keytype : ecdsa - keypath : ~/.ssh/id_ecdsa - keypass : secret commands : - execute : echo hello world","title":"Using the Remote Runner"},{"location":"user_guide/runners/remote_usage/#using-the-remote-command-runner","text":"The remote Command Runner executes commands on a remote machine. To execute commands remotely, SSH needs to be installed on the host machine and configured using a public/private key pair. This way, build-magic can execute commands without prompting the user for a password. Note To connect to or from a Windows 10 machine, OpenSSH needs to be installed on the Windows machine. Build-magic isn't compatible with other Windows SSH implementations or PuTTY .ppk files. You can find instructions on installing OpenSSH for Windows 10 here . To connect to a remote machine, the --environment option should include the user and hostname of the machine to connect to, for example: Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo hello world Optionally, the port can also be given. By default, the port SSH will use is 22. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost:2222 \\ \"echo hello world\" Config File build-magic : - stage : runner : remote environment : user@myhost:2222 commands : - execute : echo hello world","title":"Using the Remote Command Runner"},{"location":"user_guide/runners/remote_usage/#running-shell-commands","text":"The remote Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ 'ps -ef | grep python' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : ps -ef | grep python Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose -r remote -e user@myhost 'echo $SHELL' Config File build-magic : - stage : runner : remote environment : user@myhost commands : - execute : 'echo $SHELL'","title":"Running Shell Commands"},{"location":"user_guide/runners/remote_usage/#setting-the-working-directory","text":"The Working Directory is the path that build-magic operates from. By default, the Working Directory is the home directory of user used for logging into the remote machine. The Working Directory can be changed to any path the user has permission to read from with the --wd option. Command-line > build-magic --runner remote --environment user@myhost --wd ~/myproject make Config File build-magic : - stage : runner : remote environment : user@myhost working directory : ~/myproject commands : - execute : make","title":"Setting the Working Directory"},{"location":"user_guide/runners/remote_usage/#copying-files-to-the-remote-machine","text":"Individual files can be copied to the remote machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner remote \\ --environment user@myhost \\ --copy /home/myproject \\ --command execute ./configure \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : remote environment : user@myhost copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - execute : ./configure - execute : make","title":"Copying Files To The Remote Machine"},{"location":"user_guide/runners/remote_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files on the remote machine with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory on the remote machine before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. Command-line > build-magic --action cleanup \\ --runner remote \\ --environment user@myhost \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Config File build-magic : - stage : runner : remote environment : user@myhost action : cleanup commands : - build : python setup.py sdist bdist_wheel --universal - release : twine upload dist/* Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. If using the --copy option to copy files to the working directory on the remote machine, these files are deleted along with any new files created during the Stage.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/remote_usage/#working-with-publicprivate-keypairs","text":"The remote Command Runner uses SSH public/private keypairs to connect to remote machines and execute commands. By default, build-magic looks for the private key at ~/.ssh/id_rsa . The path to the private key can be specified with --parameter keypath : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keypath ~/.ssh/keys/id_rsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : - keypath : ~/.ssh/keys/id_rsa commands : - execute : echo hello world Build-magic supports several different SSH key types: rsa dsa ecdsa ed25519 The SSH key type can be specified with --parameter keytype : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : - keytype : ecdsa - keypath : ~/.ssh/id_ecdsa commands : - execute : echo hello world To use a private key protected by a passphrase, use --parameter keypass : Command-line > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --parameter keypass secret \\ --command execute 'echo hello world' Config File build-magic : - stage : runner : remote environment : user@myhost parameters : - keytype : ecdsa - keypath : ~/.ssh/id_ecdsa - keypass : secret commands : - execute : echo hello world","title":"Working with Public/Private Keypairs"},{"location":"user_guide/runners/vagrant_usage/","text":"Using the Vagrant Command Runner \u00b6 The vagrant Command Runner executes commands in a virtual machine. Vagrant is a command line utility for creating and managing virtual machines. A specialized Ruby scripted called a Vagrantfile is used to provision the virtual machine. Build-magic will start a new virtual machine provisioned by a specified Vagrantfile. The path to the Vagrantfile can be provided by the --environment option. When the Stage ends, build-magic will destroy the virtual machine so that it doesn't continue to use resources on the host machine. Note Virtual machines are significantly slower to start up compared to containers. Depending on the Vagrant Box used, the VM Provider configured, and the host machine resources, the virtual machine can take 30+ seconds to start up. Note Build-magic only supports Linux-based Vagrant Boxes with the vagrant Command Runner. Using a Virtual Machine Compared to a Container \u00b6 There are a few noteworthy differences between using the vagrant Command Runner to execute commands in a virtual machine vs using the docker Command Runner to execute commands in a container. Virtual machines much more closely resemble a full operating system compared to a container. This can be useful when testing package installation for a target operating system/distribution/version. Containers are relatively minimal and won't have a lot of programs or libraries available by default. Virtual machines are significantly slower to start up compared to a container. Virtual machines typically consume more resources (CPU, memory, disk space) on the host machine compared to containers. Running Shell Commands \u00b6 The vagrant Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ 'echo $TERM' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : 'echo $TERM' Setting the Working Directory \u00b6 When using the vagrant Command Runner, the Working Directory option --wd refers to the Working Directory within the virtual machine. Note The host directory and bind directory are set from the Vagrantfile with config.vm.synced_folder , and therefore cannot be controlled by build-magic. See the Vagrant Synced Folders documentation for details. Unlike the docker Command Runner, the Working Directory and Bind Directory for the vagrant Command Runner do not default to the same directory. The Working Directory defaults to /home/vagrant and the Bind Directory defaults to /vagrant . This means if you want the Working Directory to be set to the Bind Directory, the --wd option must be used to set the Working Directory to /vagrant . Command-line > build-magic -r vagrant -e . --wd /vagrant make Config File build-magic : - stage : runner : vagrant environment : . working directory : /vagrant commands : - execute : make Copying Files Into the Virtual Machine \u00b6 By using synced folders, all files in Host Working Directory are available from Bind Directory in the virtual machine. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Some of the synced folder implementations Vagrant uses have significant overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner vagrant \\ --environment Vagrantfile \\ --copy /home/myproject \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : vagrant environment : Vagrantfile copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make Debugging the Virtual Machine \u00b6 If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner vagrant \\ --environment Vagrantfile \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : vagrant environment : Vagrantfile action : persist commands : - execute cp The command cp will fail because it doesn't have any arguments. The virtual machine will continue to run and can be accessed with: > vagrant ssh When finished, exit the virtual machine with exit . The virtual machine can then be stopped and destroyed with: > vagrant destroy","title":"Using the Vagrant Runner"},{"location":"user_guide/runners/vagrant_usage/#using-the-vagrant-command-runner","text":"The vagrant Command Runner executes commands in a virtual machine. Vagrant is a command line utility for creating and managing virtual machines. A specialized Ruby scripted called a Vagrantfile is used to provision the virtual machine. Build-magic will start a new virtual machine provisioned by a specified Vagrantfile. The path to the Vagrantfile can be provided by the --environment option. When the Stage ends, build-magic will destroy the virtual machine so that it doesn't continue to use resources on the host machine. Note Virtual machines are significantly slower to start up compared to containers. Depending on the Vagrant Box used, the VM Provider configured, and the host machine resources, the virtual machine can take 30+ seconds to start up. Note Build-magic only supports Linux-based Vagrant Boxes with the vagrant Command Runner.","title":"Using the Vagrant Command Runner"},{"location":"user_guide/runners/vagrant_usage/#using-a-virtual-machine-compared-to-a-container","text":"There are a few noteworthy differences between using the vagrant Command Runner to execute commands in a virtual machine vs using the docker Command Runner to execute commands in a container. Virtual machines much more closely resemble a full operating system compared to a container. This can be useful when testing package installation for a target operating system/distribution/version. Containers are relatively minimal and won't have a lot of programs or libraries available by default. Virtual machines are significantly slower to start up compared to a container. Virtual machines typically consume more resources (CPU, memory, disk space) on the host machine compared to containers.","title":"Using a Virtual Machine Compared to a Container"},{"location":"user_guide/runners/vagrant_usage/#running-shell-commands","text":"The vagrant Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : echo \"hello world\" > hello.txt - execute : cat hello.txt Environment variables can be included in commands by wrapping the command in single quotes: Command-line > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ 'echo $TERM' Config File build-magic : - stage : runner : vagrant environment : Vagrantfile commands : - execute : 'echo $TERM'","title":"Running Shell Commands"},{"location":"user_guide/runners/vagrant_usage/#setting-the-working-directory","text":"When using the vagrant Command Runner, the Working Directory option --wd refers to the Working Directory within the virtual machine. Note The host directory and bind directory are set from the Vagrantfile with config.vm.synced_folder , and therefore cannot be controlled by build-magic. See the Vagrant Synced Folders documentation for details. Unlike the docker Command Runner, the Working Directory and Bind Directory for the vagrant Command Runner do not default to the same directory. The Working Directory defaults to /home/vagrant and the Bind Directory defaults to /vagrant . This means if you want the Working Directory to be set to the Bind Directory, the --wd option must be used to set the Working Directory to /vagrant . Command-line > build-magic -r vagrant -e . --wd /vagrant make Config File build-magic : - stage : runner : vagrant environment : . working directory : /vagrant commands : - execute : make","title":"Setting the Working Directory"},{"location":"user_guide/runners/vagrant_usage/#copying-files-into-the-virtual-machine","text":"By using synced folders, all files in Host Working Directory are available from Bind Directory in the virtual machine. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Some of the synced folder implementations Vagrant uses have significant overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. Command-line > build-magic \\ --runner vagrant \\ --environment Vagrantfile \\ --copy /home/myproject \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Config File build-magic : - stage : runner : vagrant environment : Vagrantfile copy from directory : /home/myproject artifacts : - main.cpp - plugins.cpp - audio.cpp commands : - install : apk add gcc - build : make","title":"Copying Files Into the Virtual Machine"},{"location":"user_guide/runners/vagrant_usage/#debugging-the-virtual-machine","text":"If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. Command-line > build-magic --runner vagrant \\ --environment Vagrantfile \\ --action persist \\ --command execute \"cp\" Config File build-magic : - stage : runner : vagrant environment : Vagrantfile action : persist commands : - execute cp The command cp will fail because it doesn't have any arguments. The virtual machine will continue to run and can be accessed with: > vagrant ssh When finished, exit the virtual machine with exit . The virtual machine can then be stopped and destroyed with: > vagrant destroy","title":"Debugging the Virtual Machine"}]}