{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to build-magic \ud83d\udd28\u2728 An un-opinionated, general purpose automation tool. Build-magic is a command-line application for automating build, test, install, and deploy tasks. It's designed to be easy to use by both developers and DevOps engineers. Using build-magic is as simple as: > build-magic \"echo hello world!\" But can support complex build automation with multiple steps such as: > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --cleanup \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Build-magic can also execute a batch of commands in a config file such as: > build-magic -C release.yaml Or, if the config file is named build-magic.yaml , can be run similar to the make command with: > build-magic all Build-magic lets you work the way you want to work. Build and test your Linux application on a Windows laptop. Install and test your application in a VM. Automate your build, test, and deploy pipeline on your laptop or in the cloud. Build-magic can execute commands on your local machine, on a remote server, in a Docker container, or in a virtual machine. What build-magic \"Is\" A command-line automation tool for running commands locally, remotely, in a container, or in a VM. The complexity of what build-magic can do is limited primarily by your imagination. Build-magic strives to enable developers to simplifier their application builds in a portable, user-friendly way. What build-magic \"Is Not\" A CI/CD tool replacement. There are plenty of great CI/CD tools out there. Build-magic isn't a replacement for Jenkins, GitLab CI, or GitHub Actions. In addition to build automation, these tools bake in notifications, post webhooks for source control events, and are generally cloud based. Build-magic is instead focused on build automation you can control locally. CI/CD tools are extremely useful, and Jenkins, GitLab CI, and GitHub Actions can use build-magic to minimize differences between production builds in the cloud and development builds on your laptop.","title":"Home"},{"location":"#welcome-to-build-magic","text":"An un-opinionated, general purpose automation tool. Build-magic is a command-line application for automating build, test, install, and deploy tasks. It's designed to be easy to use by both developers and DevOps engineers. Using build-magic is as simple as: > build-magic \"echo hello world!\" But can support complex build automation with multiple steps such as: > build-magic \\ --runner docker \\ --environment ubuntu:latest \\ --verbose \\ --cleanup \\ --command execute \"./configure CC=c99 CFLAGS=-O2 LIBS=-lposix\" \\ --command build \"make\" \\ --command test \"make test\" \\ --command execute \"tar -czf myapp.tar.gz build/*\" \\ --command release \"jfrog rt upload myapp.tar.gz my-artifactory\" Build-magic can also execute a batch of commands in a config file such as: > build-magic -C release.yaml Or, if the config file is named build-magic.yaml , can be run similar to the make command with: > build-magic all Build-magic lets you work the way you want to work. Build and test your Linux application on a Windows laptop. Install and test your application in a VM. Automate your build, test, and deploy pipeline on your laptop or in the cloud. Build-magic can execute commands on your local machine, on a remote server, in a Docker container, or in a virtual machine.","title":"Welcome to build-magic &#x1F528;&#x2728;"},{"location":"#what-build-magic-is","text":"A command-line automation tool for running commands locally, remotely, in a container, or in a VM. The complexity of what build-magic can do is limited primarily by your imagination. Build-magic strives to enable developers to simplifier their application builds in a portable, user-friendly way.","title":"What build-magic \"Is\""},{"location":"#what-build-magic-is-not","text":"A CI/CD tool replacement. There are plenty of great CI/CD tools out there. Build-magic isn't a replacement for Jenkins, GitLab CI, or GitHub Actions. In addition to build automation, these tools bake in notifications, post webhooks for source control events, and are generally cloud based. Build-magic is instead focused on build automation you can control locally. CI/CD tools are extremely useful, and Jenkins, GitLab CI, and GitHub Actions can use build-magic to minimize differences between production builds in the cloud and development builds on your laptop.","title":"What build-magic \"Is Not\""},{"location":"class_diagram/","text":"classDiagram CommandRunner o-- Local : Realizes CommandRunner o-- Remote : Realizes CommandRunner o-- Docker : Realizes CommandRunner o-- Vagrant : Realizes CommandRunner --|> Status : Returns StageFactory \"1\" --|> \"1..n\" Stage Stage \"1\" *-- \"1\" CommandRunner Stage \"1\" ..|> \"1\" MacroFactory : Calls Macro \"1..n\" <|-- \"1\" MacroFactory : Generates Stage \"1\" *-- \"1..n\" Macro Stage \"1\" *-- \"1..n\" Status Output \"1\" <|.. \"1\" Stage : Calls Output <|-- Basic : Inherits Output <|-- Silent : Inherits Output <|-- Tty : Inherits Action <|-- Default : Inherits Action <|-- Cleanup : Inherits Action <|-- Persist : Inherits CommandRunner o-- Action : Dynamically binds class CLI class StageFactory { -build(args) Stage -_build_parameters(List~Tuple~ parameters) dict -_build_command_runner(args) CommandRunner -_build_macros(List~str~ commands, List~str~ artifacts) List~Macro~ } class Stage { -Action _action -CommandRunner _command_runner -List~str~ _directives -List~Macro~ _macros -int _result -List~int~ _results +bool is_setup +int|str sequence +str name -_get_action_function(str method) Callable +setup() +run(bool continue_on_fail, bool verbose) int } class Engine { -bool _continue_on_fail -List~Stage~ _stages -bool _verbose +run() int } class Action { <<Abstract>> +dict add_prefix +dict add_suffix +dict mapping } class Default class Cleanup class Persist class CommandRunner { <<Abstract>> +str environment +str working_directory +str copy_from_directory +int timeout +List~str~ artifacts +dict parameters +str name -_filter_parameters(dict parameters, Tuple~str~ parameter_names) dict +cd(str|Path directory) bool +copy(str|Path src, str|Path dst) bool +provision() Status +prepare() +execute(Macro macro) Status +teardown() Status } class Local { +prepare() bool } class Remote { -_get_ssh_key() PKey +connect() SSHClient +copy(str|Path src, str|Path dst) bool +prepare() bool +execute(Macro macro) Status } class Docker { +prepare() bool +execute(Macro macro) Status } class Vagrant { +prepare() bool +execute(Macro macro) Status } class Macro { +str command +int|str sequence +str prefix +str suffix +as_string() str +as_list() List~str~ } class MacroFactory { -List~str~ commands +generate() List~Macro~ } class Status { +str stdout +str stderr +int exit_code -_validate(Any other)$ None +__repr__() str +__eq__(Any other) bool +__lt__(Any other) bool +__le__(Any other) bool +__gt__(Any other) bool +__ge__(Any other) bool } class Output { <<Abstract>> +datetime timer +start_job() +end_job() +no_job() +start_stage() +end_stage() +macro_start() +macro_status() +error() +info() +log(str message) +print_message(str message, bool is_error) None -display(str line, bool error)$ None } class Basic { +start_job() None +end_job() None +no_job() None +start_stage(str|int stage_number, str Name) None +end_stage(str|int stage_number, int status_code, str name) None +macro_start() None +macro_status(str directive, str command, int status_code) None +error(str error) None +info(str msg) None } class Tty { -Terminal _term +get_width() int +get_height() int +start_job() None +end_job() None +no_job() None +start_stage(str|int stage_number, str Name) None +end_stage(str|int stage_number, int status_code, str name) None +macro_start(str directive, str command) None +macro_status(str directive, str command, int status_code) None +error(str error) None +info(str msg) None } class Silent class EnumExt { +names() Tuple~str~ +available() Tuple~Any~ +values() Tuple~Any~ }","title":"Class diagram"},{"location":"getting_started/","text":"Getting Started Requirements The build-magic project is written in Python and is cross-platform. Operating System: MacOS, Windows, or Linux Python 3.6+ Docker (optional) Vagrant (optional) OpenSSH (optional) Installation Installing From PyPI You can install build-magic using pip with the following command: pip install build-magic Alternatively, if you want build-magic to run from an isolated environment, you can use: pipx install build-magic Installing From Source The build-magic project is written in Python. First, create a new virtual environment for development with: python3 -m venv /path/to/new/virtual/environment Alternatively, you can create a virtual environment with conda or virtualenv . Be sure to activate your virtual environment with: source /path/to/new/virtual/environment/bin/activate Next, navigate to the directory where you want to install build-magic and clone the repository using HTTPS with: git clone https://github.com/cmmorrow/build-magic.git Or using SSH with: git clone git@github.com:cmmorrow/build-magic.git Or using the GitHub CLI with: gh repo clone cmmorrow/build-magic Getting The Most Out of build-magic With Optional Command Runners In addition to running commands on your machine, build-magic can also run commands in a virtual machine, a Docker container, or on a remote machine. Using Docker To use build-magic to run commands in a container, you will need to have Docker installed. Instructions on how to install Docker can be found here . Using A Virtual Machine Build-magic can execute commands in a virtual machine via Vagrant . Vagrant is a command-line tool for controlling virtual machines. Instructions on how to install Vagrant can be found here . Using a Remote Machine Build-magic can execute commands on a remote machine via SSH . To allow remote command execution, SSH client needs to be installed on the local machine and SSH server needs to be installed and running on the remote machine. If you're using MacOS or Linux, both SSH client and SSH server should be installed. If you are using Windows 10, SSH client and SSH server are installable features. Instructions for installing SSH on Windows 10 or Windows Server 2019 can be found here . Currently, build-magic only supports SSH connections via public/private key pairs for password-less login. Password-less login needs to be working before build-magic can make use of remote command execution. You can read more about how to configure public/private key pairs on SSH.com . Basic Usage You can verify build-magic is install by running the following command from a command prompt: build-magic --verbose \"echo 'hello world'\" You should see build-magic run and output hello world","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#requirements","text":"The build-magic project is written in Python and is cross-platform. Operating System: MacOS, Windows, or Linux Python 3.6+ Docker (optional) Vagrant (optional) OpenSSH (optional)","title":"Requirements"},{"location":"getting_started/#installation","text":"","title":"Installation"},{"location":"getting_started/#installing-from-pypi","text":"You can install build-magic using pip with the following command: pip install build-magic Alternatively, if you want build-magic to run from an isolated environment, you can use: pipx install build-magic","title":"Installing From PyPI"},{"location":"getting_started/#installing-from-source","text":"The build-magic project is written in Python. First, create a new virtual environment for development with: python3 -m venv /path/to/new/virtual/environment Alternatively, you can create a virtual environment with conda or virtualenv . Be sure to activate your virtual environment with: source /path/to/new/virtual/environment/bin/activate Next, navigate to the directory where you want to install build-magic and clone the repository using HTTPS with: git clone https://github.com/cmmorrow/build-magic.git Or using SSH with: git clone git@github.com:cmmorrow/build-magic.git Or using the GitHub CLI with: gh repo clone cmmorrow/build-magic","title":"Installing From Source"},{"location":"getting_started/#getting-the-most-out-of-build-magic-with-optional-command-runners","text":"In addition to running commands on your machine, build-magic can also run commands in a virtual machine, a Docker container, or on a remote machine.","title":"Getting The Most Out of build-magic With Optional Command Runners"},{"location":"getting_started/#using-docker","text":"To use build-magic to run commands in a container, you will need to have Docker installed. Instructions on how to install Docker can be found here .","title":"Using Docker"},{"location":"getting_started/#using-a-virtual-machine","text":"Build-magic can execute commands in a virtual machine via Vagrant . Vagrant is a command-line tool for controlling virtual machines. Instructions on how to install Vagrant can be found here .","title":"Using A Virtual Machine"},{"location":"getting_started/#using-a-remote-machine","text":"Build-magic can execute commands on a remote machine via SSH . To allow remote command execution, SSH client needs to be installed on the local machine and SSH server needs to be installed and running on the remote machine. If you're using MacOS or Linux, both SSH client and SSH server should be installed. If you are using Windows 10, SSH client and SSH server are installable features. Instructions for installing SSH on Windows 10 or Windows Server 2019 can be found here . Currently, build-magic only supports SSH connections via public/private key pairs for password-less login. Password-less login needs to be working before build-magic can make use of remote command execution. You can read more about how to configure public/private key pairs on SSH.com .","title":"Using a Remote Machine"},{"location":"getting_started/#basic-usage","text":"You can verify build-magic is install by running the following command from a command prompt: build-magic --verbose \"echo 'hello world'\" You should see build-magic run and output hello world","title":"Basic Usage"},{"location":"user_guide/basic_concepts/","text":"Basic Concepts To get the most out of build-magic, you should become familiar with build-magic's core concepts: Commands Directives Command Runners Output Formats Working Directory Stages Config File Targets Job Actions Parameters Many of these terms will look familiar if you've used Jenkins or GitHub Actions, but the meaning of these terms can be quite different for build-magic. Commands Build-magic's primary focus is executing Commands. A Command is a valid command-line interface command that can be executed in a single line. Commands are executed by build-magic using the default shell of the machine the Command is executing on. Each Command that build-magic executes returns stdout, stderr, and an exit code. If a Command returns an exit code other than 0, build-magic will by default stop execution and display any error message from stderr. There are two ways to execute Commands with build-magic. The simplest way is to execute a single command as an argument to the build-magic command: > build-magic make In this case, build-magic simply executes the make Command in the current directory. Note When using a command that has multiple arguments or makes use of shell operators such as redirection > or piping | It will be necessary to wrap the command in single quotes so that the shell doesn't try to interpret the operator. Build-magic can also execute multiple commands with the --command option in the order they are provided: > build-magic \\ --command execute 'tar -czf myfiles.tar.gz file1.txt file2.txt' \\ --command execute 'rm file1.txt file2.txt' Note that the word \"execute\" is used before the commands. This is a Directive and is described below. Each command is also surrounded in quotes, otherwise build-magic gets confused and thinks you are trying to pass additional arguments. Directives Directives describe the type of Command being executed. All Commands that build-magic executes must have a Directive associated with them. Directives don't impart any special meaning to build-magic and are simply used to describe the command. Valid Directives that build-magic understands are: execute build test install release deploy If only a single command is passed to build-magic without a Directive, the \"execute\" Directive is used by default. Command Runners Build-magic can execute Commands on the local machine, in a container, in a virtual machine, or on a remote machine. You tell build-magic how you want to execute the Commands by specify a Command Runner with the --runner option. Valid Command Runners are: local docker vagrant remote By default, the local Command Runner is used if the --runner option isn't provided. All Commands Runners except for the local Command Runner must also provide the --environment option. The environment depends on the Command Runner being used: docker : The name of the Docker container - ubuntu:latest vagrant : The path to the Vagrantfile - ./Vagrantfile remote : The username and hostname of the remote machine to connect to - user@myhost Example: > build-magic --runner docker --environment ubuntu:latest make Output Formats Build-magic reports it's progress and status to stdout on a terminal. There are three different output format based on your preference and use case: fancy plain quiet Working Directory The Working Directory is the path that build-magic operates from. Non-absolute paths in commands that build-magic executes are relative to the Working Directory. Stages A Stage is a collection of Commands. When you use build-magic from the command-line, all the Commands are gathered into a single stage and executed as a single collection. Build-magic can execute multiple Stages, but only by using a Config File. Config File A build-magic Config File is a YAML file that describes the Stages and Commands to run, and how to run them. The Config File consists of a list of Stages to be executed in order. Multiple Config Files can be provided, in which case the Stages are executed in the order they are provided in each Config File. Targets A Target is a Stage name that can be used to run the corresponding Stage regardless of the Stage order in the Config file. Multiple Targets can be specified to reorder Stages at runtime. Targets can be used to filter the Stages to execute. Job A Job is a collection of all the Stages that build-magic is going to execute. If more than one Config File is provided, the Job consists of every Stage from each Config File. Actions Actions can be used to modify build-magic's default behavior by adding setup and teardown behavior to a Stage. Build-magic's Actions are: default: Start up and destroy the virtual machine or container when the docker or vagrant Command Runner is used by the Stage. No setup or teardown is performed for the local or remote Command Runners. persist: Don't destroy the virtual machine or container used by the Stage. Useful for debugging. cleanup: Delete any files created by a Stage. Parameters Parameters are optional configurations that are specific to a particular Command Runner. Command Runner Parameter Description remote keytype The SSH key type (dsa, rsa, ecdsa, ed25519) remote keypath The path to the SSH private key remote keypass The private key passphrase if set vagrant hostwd The working directory of the host (local machine) vagrant bind The vm directory that is bound to the host docker hostwd The working directory of the host (local machine) docker bind A bind path on the container to the hostwd","title":"Basic Concepts"},{"location":"user_guide/basic_concepts/#basic-concepts","text":"To get the most out of build-magic, you should become familiar with build-magic's core concepts: Commands Directives Command Runners Output Formats Working Directory Stages Config File Targets Job Actions Parameters Many of these terms will look familiar if you've used Jenkins or GitHub Actions, but the meaning of these terms can be quite different for build-magic.","title":"Basic Concepts"},{"location":"user_guide/basic_concepts/#commands","text":"Build-magic's primary focus is executing Commands. A Command is a valid command-line interface command that can be executed in a single line. Commands are executed by build-magic using the default shell of the machine the Command is executing on. Each Command that build-magic executes returns stdout, stderr, and an exit code. If a Command returns an exit code other than 0, build-magic will by default stop execution and display any error message from stderr. There are two ways to execute Commands with build-magic. The simplest way is to execute a single command as an argument to the build-magic command: > build-magic make In this case, build-magic simply executes the make Command in the current directory. Note When using a command that has multiple arguments or makes use of shell operators such as redirection > or piping | It will be necessary to wrap the command in single quotes so that the shell doesn't try to interpret the operator. Build-magic can also execute multiple commands with the --command option in the order they are provided: > build-magic \\ --command execute 'tar -czf myfiles.tar.gz file1.txt file2.txt' \\ --command execute 'rm file1.txt file2.txt' Note that the word \"execute\" is used before the commands. This is a Directive and is described below. Each command is also surrounded in quotes, otherwise build-magic gets confused and thinks you are trying to pass additional arguments.","title":"Commands"},{"location":"user_guide/basic_concepts/#directives","text":"Directives describe the type of Command being executed. All Commands that build-magic executes must have a Directive associated with them. Directives don't impart any special meaning to build-magic and are simply used to describe the command. Valid Directives that build-magic understands are: execute build test install release deploy If only a single command is passed to build-magic without a Directive, the \"execute\" Directive is used by default.","title":"Directives"},{"location":"user_guide/basic_concepts/#command-runners","text":"Build-magic can execute Commands on the local machine, in a container, in a virtual machine, or on a remote machine. You tell build-magic how you want to execute the Commands by specify a Command Runner with the --runner option. Valid Command Runners are: local docker vagrant remote By default, the local Command Runner is used if the --runner option isn't provided. All Commands Runners except for the local Command Runner must also provide the --environment option. The environment depends on the Command Runner being used: docker : The name of the Docker container - ubuntu:latest vagrant : The path to the Vagrantfile - ./Vagrantfile remote : The username and hostname of the remote machine to connect to - user@myhost Example: > build-magic --runner docker --environment ubuntu:latest make","title":"Command Runners"},{"location":"user_guide/basic_concepts/#output-formats","text":"Build-magic reports it's progress and status to stdout on a terminal. There are three different output format based on your preference and use case: fancy plain quiet","title":"Output Formats"},{"location":"user_guide/basic_concepts/#working-directory","text":"The Working Directory is the path that build-magic operates from. Non-absolute paths in commands that build-magic executes are relative to the Working Directory.","title":"Working Directory"},{"location":"user_guide/basic_concepts/#stages","text":"A Stage is a collection of Commands. When you use build-magic from the command-line, all the Commands are gathered into a single stage and executed as a single collection. Build-magic can execute multiple Stages, but only by using a Config File.","title":"Stages"},{"location":"user_guide/basic_concepts/#config-file","text":"A build-magic Config File is a YAML file that describes the Stages and Commands to run, and how to run them. The Config File consists of a list of Stages to be executed in order. Multiple Config Files can be provided, in which case the Stages are executed in the order they are provided in each Config File.","title":"Config File"},{"location":"user_guide/basic_concepts/#targets","text":"A Target is a Stage name that can be used to run the corresponding Stage regardless of the Stage order in the Config file. Multiple Targets can be specified to reorder Stages at runtime. Targets can be used to filter the Stages to execute.","title":"Targets"},{"location":"user_guide/basic_concepts/#job","text":"A Job is a collection of all the Stages that build-magic is going to execute. If more than one Config File is provided, the Job consists of every Stage from each Config File.","title":"Job"},{"location":"user_guide/basic_concepts/#actions","text":"Actions can be used to modify build-magic's default behavior by adding setup and teardown behavior to a Stage. Build-magic's Actions are: default: Start up and destroy the virtual machine or container when the docker or vagrant Command Runner is used by the Stage. No setup or teardown is performed for the local or remote Command Runners. persist: Don't destroy the virtual machine or container used by the Stage. Useful for debugging. cleanup: Delete any files created by a Stage.","title":"Actions"},{"location":"user_guide/basic_concepts/#parameters","text":"Parameters are optional configurations that are specific to a particular Command Runner. Command Runner Parameter Description remote keytype The SSH key type (dsa, rsa, ecdsa, ed25519) remote keypath The path to the SSH private key remote keypass The private key passphrase if set vagrant hostwd The working directory of the host (local machine) vagrant bind The vm directory that is bound to the host docker hostwd The working directory of the host (local machine) docker bind A bind path on the container to the hostwd","title":"Parameters"},{"location":"user_guide/cli_usage/","text":"Using the build-magic Command-line Interface Synopsis Provide Commands build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] <command> build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] [--copy <copy-from>] [--continue | --stop] [-c | --command <directive command>]... [<artifact>...] Provide Config Files build-magic [--fancy | --plain | --quiet] [--verbose] [-C | --config <config-file>] [-t | --target <stage name>]... build-magic [--fancy | --plain | --quiet] [--verbose] [all | <stage name> | [-t | --target <stage name>]...] Usage There are two ways to use build-magic from the command-line. Specify commands to execute from the command line Execute a single command where any arguments provided after valid options are interpreted as part of <command> . For example: build-magic --verbose echo hello world Alternatively, execute a single stage with multiple commands. This form must use one or more [-c | --command <directive command>] options to specify the commands. For example: build-magic --verbose \\ --command execute 'echo \"hello world\" > hello.txt' \\ --command execute 'cat hello.txt' In this form, any arguments provided after valid options are interpreted as one or more <artifact> . Artifact arguments are ignored unless the --copy option is used. The artifacts must exist in <copy-from> to be copied to the working directory. For example: build-magic --copy src --command build 'make' audio.c equalizer.c effects.c Specify stages and commands to execute from a config file Execute multiple stages with multiple commands using a config file. For example: build-magic --config my_config.yaml A config file in a different directory can also be used by providing the relative or absolute path to the config file: build-magic --config my_project/config.yaml Multiple config files can be specified and they will be executed in order. build-magic --config config1.yaml --config config2.yaml Execute a specific stage in a config file with the --target option. If for example, a config file has three stages named build, test, and deploy, the deploy stage can be run on it's own with: build-magic --config my_config.yaml --target deploy Multiple targets can be specified to change the stage execution order of a config file. Running tests before building can be accomplished with: build-magic --config my_config.yaml --target test --target build Named stages in a config file can also be run similar to a Makefile by specifying the stage name: build-magic deploy However, this usage will only work if the config file is named one of the following default filenames: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml To run all the stages in a default named config file, use: build-magic all Note The make like usage is more limited than using the --target option. Only a single stage can be executed by name as an argument, or all stages can be executed in order with all . Also, a config file must have one of the default filenames mentioned above, which also means multiple config files cannot be used. The config file must also be in the directory build-magic is being executed from. If a directory has more than one of the above named files in the same directory, an error is returned when running build-magic. While convenient, it's recommended for these reasons to use the --target option instead. It is also possible to use the --target option with a config file that has a default filename without having to specify the config filename with --config . For example: build-magic --target test --target build Note If running build-magic from a directory that has a config file with a default filename and another config file is specified with the --config option, both config files will be executed with the config file with the default filename running first. Description --help - Prints build-magic's help text. --version - Prints the build-magic version. -r , --runner - The command runner to use for executing commands. Must be one of local , remote , vagrant or docker . The default command runner is local . -e , --environment - The environment to use for the specified command runner. The context of the environment depends on the command runner. local - The environment option is ignored. remote - The host machine to connect to in the form user@host:port . If port isn't provided, it will default to 22. vagrant - The path to the Vagrantfile to use for provisioning the Vagrant virtual machine. docker - The name of the container to use. Optionally, the container tag can be specified in the form container:tag . If --runner is defined and not equal to local , --environment is required. --name - Optional name <stage> to give the executing stage. If --name isn't provided, the default stage name is 1. --wd - The working directory build-magic will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote command runners, the working directory is on the host machine. For vagrant and docker command runners, the working directory is on the guest machine, i.e. inside the virtual machine or running container. If the copy option is provided along with <artifacts> , the <artifacts> are copied from <copy-from> to <working-directory> . -p , --parameter - Key/value pairs <p-name p-value> of optional command runner specific configurations. Can be provided multiple times. --action - Runs the specified setup and teardown action. default - Performs container and vm setup and teardown for the docker and vagrant command runners. cleanup - Deletes any new files or newly created copies of existing files after the last command is executed and before build-magic exits. persist - Only used by the vagrant and docker command runners. If specified, the virtual machine or container won't be destroyed after build-magic exits. The default action is set by default. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. --copy - Copy <artifacts> from <copy-from> to <working-directory> . --continue , --stop - Default setting is --stop . If --stop is set, build-magic will exit if a command fails (returns a non-zero exit code). If --continue is set, build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using --continue can lead to unstable behavior as failures can cascade to subsequent commands. -c , --command - A <directive command> pair to execute. The command must be wrapped in quotes for build-magic to parse it correctly. For example: --command execute \"echo 'hello world'\" . Can be provided multiple times. -C , --config - Executes the stages in <config-file> . -t , --target - Matches the name of a stage in the specified config file or files to execute. If <stage name> doesn't match a named stage in any of the config files, an error is returned. Multiple targets can be provided and each corresponding stage will be executed in the order the targets are specified.","title":"Using the CLI"},{"location":"user_guide/cli_usage/#using-the-build-magic-command-line-interface","text":"","title":"Using the build-magic Command-line Interface"},{"location":"user_guide/cli_usage/#synopsis","text":"","title":"Synopsis"},{"location":"user_guide/cli_usage/#provide-commands","text":"build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] <command> build-magic [-r | --runner (local | remote | vagrant | docker)] [-e | --environment <env>] [--name <stage>] [--wd <working-directory>] [-p | --parameter <p-name p-value>]... [--action (default | cleanup | persist)] [--fancy | --plain | --quiet] [--verbose] [--copy <copy-from>] [--continue | --stop] [-c | --command <directive command>]... [<artifact>...]","title":"Provide Commands"},{"location":"user_guide/cli_usage/#provide-config-files","text":"build-magic [--fancy | --plain | --quiet] [--verbose] [-C | --config <config-file>] [-t | --target <stage name>]... build-magic [--fancy | --plain | --quiet] [--verbose] [all | <stage name> | [-t | --target <stage name>]...]","title":"Provide Config Files"},{"location":"user_guide/cli_usage/#usage","text":"There are two ways to use build-magic from the command-line.","title":"Usage"},{"location":"user_guide/cli_usage/#specify-commands-to-execute-from-the-command-line","text":"Execute a single command where any arguments provided after valid options are interpreted as part of <command> . For example: build-magic --verbose echo hello world Alternatively, execute a single stage with multiple commands. This form must use one or more [-c | --command <directive command>] options to specify the commands. For example: build-magic --verbose \\ --command execute 'echo \"hello world\" > hello.txt' \\ --command execute 'cat hello.txt' In this form, any arguments provided after valid options are interpreted as one or more <artifact> . Artifact arguments are ignored unless the --copy option is used. The artifacts must exist in <copy-from> to be copied to the working directory. For example: build-magic --copy src --command build 'make' audio.c equalizer.c effects.c","title":"Specify commands to execute from the command line"},{"location":"user_guide/cli_usage/#specify-stages-and-commands-to-execute-from-a-config-file","text":"Execute multiple stages with multiple commands using a config file. For example: build-magic --config my_config.yaml A config file in a different directory can also be used by providing the relative or absolute path to the config file: build-magic --config my_project/config.yaml Multiple config files can be specified and they will be executed in order. build-magic --config config1.yaml --config config2.yaml Execute a specific stage in a config file with the --target option. If for example, a config file has three stages named build, test, and deploy, the deploy stage can be run on it's own with: build-magic --config my_config.yaml --target deploy Multiple targets can be specified to change the stage execution order of a config file. Running tests before building can be accomplished with: build-magic --config my_config.yaml --target test --target build Named stages in a config file can also be run similar to a Makefile by specifying the stage name: build-magic deploy However, this usage will only work if the config file is named one of the following default filenames: build-magic.yaml build_magic.yaml build-magic.yml build_magic.yml To run all the stages in a default named config file, use: build-magic all Note The make like usage is more limited than using the --target option. Only a single stage can be executed by name as an argument, or all stages can be executed in order with all . Also, a config file must have one of the default filenames mentioned above, which also means multiple config files cannot be used. The config file must also be in the directory build-magic is being executed from. If a directory has more than one of the above named files in the same directory, an error is returned when running build-magic. While convenient, it's recommended for these reasons to use the --target option instead. It is also possible to use the --target option with a config file that has a default filename without having to specify the config filename with --config . For example: build-magic --target test --target build Note If running build-magic from a directory that has a config file with a default filename and another config file is specified with the --config option, both config files will be executed with the config file with the default filename running first.","title":"Specify stages and commands to execute from a config file"},{"location":"user_guide/cli_usage/#description","text":"--help - Prints build-magic's help text. --version - Prints the build-magic version. -r , --runner - The command runner to use for executing commands. Must be one of local , remote , vagrant or docker . The default command runner is local . -e , --environment - The environment to use for the specified command runner. The context of the environment depends on the command runner. local - The environment option is ignored. remote - The host machine to connect to in the form user@host:port . If port isn't provided, it will default to 22. vagrant - The path to the Vagrantfile to use for provisioning the Vagrant virtual machine. docker - The name of the container to use. Optionally, the container tag can be specified in the form container:tag . If --runner is defined and not equal to local , --environment is required. --name - Optional name <stage> to give the executing stage. If --name isn't provided, the default stage name is 1. --wd - The working directory build-magic will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote command runners, the working directory is on the host machine. For vagrant and docker command runners, the working directory is on the guest machine, i.e. inside the virtual machine or running container. If the copy option is provided along with <artifacts> , the <artifacts> are copied from <copy-from> to <working-directory> . -p , --parameter - Key/value pairs <p-name p-value> of optional command runner specific configurations. Can be provided multiple times. --action - Runs the specified setup and teardown action. default - Performs container and vm setup and teardown for the docker and vagrant command runners. cleanup - Deletes any new files or newly created copies of existing files after the last command is executed and before build-magic exits. persist - Only used by the vagrant and docker command runners. If specified, the virtual machine or container won't be destroyed after build-magic exits. The default action is set by default. --fancy - This option is the default unless --plain or --quiet is used. If specified, build-magic will check to see if it's being executed in a TTY, and if so, use colored text, cursor repositioning, and format stdout to fit the terminal size. Otherwise, build-magic will assume an output width of 80 characters. --plain - If specified, build-magic will write it's output to stdout in a log-like format ideal for non-interactive use. --quiet - If specified, build-magic will suppress it's output to stdout. --verbose - If specified, the stdout output of each command will be captured and printed after the execution of the corresponding command. --copy - Copy <artifacts> from <copy-from> to <working-directory> . --continue , --stop - Default setting is --stop . If --stop is set, build-magic will exit if a command fails (returns a non-zero exit code). If --continue is set, build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using --continue can lead to unstable behavior as failures can cascade to subsequent commands. -c , --command - A <directive command> pair to execute. The command must be wrapped in quotes for build-magic to parse it correctly. For example: --command execute \"echo 'hello world'\" . Can be provided multiple times. -C , --config - Executes the stages in <config-file> . -t , --target - Matches the name of a stage in the specified config file or files to execute. If <stage name> doesn't match a named stage in any of the config files, an error is returned. Multiple targets can be provided and each corresponding stage will be executed in the order the targets are specified.","title":"Description"},{"location":"user_guide/config_usage/","text":"Defining build-magic config files Build-magic supports executing multiple stages as static, repeatable jobs with a config file. A build-magic config file is a YAML file with the following structure: build-magic : - stage : name : Build Project working directory : /home/myproject commands : - build : make - stage : name : Run tests working directory : /home/myproject commands : - execute : service start mydb - test : make test - execute : service stop mydb - stage : name : Package Fedora working directory : /home/myproject cleanup : true commands : - build : make rpm - release : jfrog rt upload \"build/RPMS/x86_64/(*).rpm\" my-artifactory build-magic - Each build-magic config file must start with build-magic on the first line. The type of the build-magic property is an array of stage properties. The build-magic property must define at least one stage . stage - Each stage is an object that defines the same properties as the CLI. The only property of stage that's required is commands . name - Optional name to give the executing stage . If name isn't provided, the default stage name is 1, and each subsequent stage name is incremented by 1. runner - The command runner to use for executing commands. The value must be one of local , remote , vagrant or docker . The default command runner is local . environment - The environment to use for the specified command runner. If the runner property is defined and not equal to local , the environment property is required. action The setup and teardown action to use. The value must be one of default , cleanup , or persist . The default action is default . continue on fail - If true , build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using continue can lead to unstable behavior as failures can cascade to subsequent commands. copy from directory - The path to copy artifacts from. If defined, build-magic will copy the array of items in artifacts to working directory . working directory - The working directory the stage will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote runner , the working directory is on the host machine. For the vagrant and docker runner , the working directory is on the guest machine, i.e. inside the virtual machine or running container. artifacts - Files to be copied from the copy from directory to the working directory . Artifacts are ignored unless the copy from directory option is set. The artifacts must exist in copy from directory path to be copied to the working directory. parameters - A list of key/value pairs of command runner specific configurations. commands - A list of key/value pairs, where the key is a directive and the value is the command to execute.","title":"Defining Config Files"},{"location":"user_guide/config_usage/#defining-build-magic-config-files","text":"Build-magic supports executing multiple stages as static, repeatable jobs with a config file. A build-magic config file is a YAML file with the following structure: build-magic : - stage : name : Build Project working directory : /home/myproject commands : - build : make - stage : name : Run tests working directory : /home/myproject commands : - execute : service start mydb - test : make test - execute : service stop mydb - stage : name : Package Fedora working directory : /home/myproject cleanup : true commands : - build : make rpm - release : jfrog rt upload \"build/RPMS/x86_64/(*).rpm\" my-artifactory build-magic - Each build-magic config file must start with build-magic on the first line. The type of the build-magic property is an array of stage properties. The build-magic property must define at least one stage . stage - Each stage is an object that defines the same properties as the CLI. The only property of stage that's required is commands . name - Optional name to give the executing stage . If name isn't provided, the default stage name is 1, and each subsequent stage name is incremented by 1. runner - The command runner to use for executing commands. The value must be one of local , remote , vagrant or docker . The default command runner is local . environment - The environment to use for the specified command runner. If the runner property is defined and not equal to local , the environment property is required. action The setup and teardown action to use. The value must be one of default , cleanup , or persist . The default action is default . continue on fail - If true , build-magic will try to continue execution even if a command fails. Warning Depending on the commands being executed, using continue can lead to unstable behavior as failures can cascade to subsequent commands. copy from directory - The path to copy artifacts from. If defined, build-magic will copy the array of items in artifacts to working directory . working directory - The working directory the stage will operate from. If not specified, the default working directory is the current directory. In the case of the local and remote runner , the working directory is on the host machine. For the vagrant and docker runner , the working directory is on the guest machine, i.e. inside the virtual machine or running container. artifacts - Files to be copied from the copy from directory to the working directory . Artifacts are ignored unless the copy from directory option is set. The artifacts must exist in copy from directory path to be copied to the working directory. parameters - A list of key/value pairs of command runner specific configurations. commands - A list of key/value pairs, where the key is a directive and the value is the command to execute.","title":"Defining build-magic config files"},{"location":"user_guide/runners/docker_usage/","text":"Using the Docker Command Runner The docker Command Runner executes commands in a container. Build-magic will start a new container named build-magic using the image specified by --environment . The container will start detached from the build-magic sub-process, use a pseudo TTY, and override the container entrypoint to /bin/sh . Note Build-magic only supports Linux-based containers with the docker Command Runner. Windows-based container will fail to launch. Running Shell Commands The docker Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ 'echo $TERM' Setting the Working Directory When using the docker Command Runner, the Working Directory option --wd refers to the Working Directory within the container. Build-magic mounts a local directory, referred to as the Host Working Directory, to a Bind Directory in the container. The Bind Directory in the container might or might not be the same as the Working Directory. By default, the Host Working Directory is the current directory build-magic is executed from, but can be changed with --parameter hostwd . > build-magic -r docker -e alpine --parameter hostwd /home/myproject make The Bind Directory and Working Directory both default to /build-magic in the container. The Bind Directory can be changed with --parameter bind . > build-magic -r docker -e alpine --parameter bind /app --wd /app make Just as with every other Command Runner, the Working Directory can be changed with the --wd option. Copying Files Into the Container By establishing a mount, all files in Host Working Directory are available from Bind Directory in the container. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Docker has some overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. > build-magic \\ --runner docker \\ --environment alpine:latest \\ --copy /home/myproject \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Instead of copying individual files to the Working Directory, an entire directory can be used by the container by setting the Host Working Directory, Bind Directory, and Working Directory: > build-magic \\ --runner docker \\ --environment alpine:latest \\ --parameter hostwd /home/myproject \\ --parameter bind /app \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' Cleaning Up New Files Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the Host Working Directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If the Working Directory is different from the Bind Directory, all files will be lost when the build-magic container is destroyed when build-magic exits. However, if the Working Directory is also the Bind Directory, any newly created files in the Host Working Directory will be deleted. The exception is for files that are copied to the Host Working Directory from a directory specified with the --copy option. Since these files are copied before the Stage starts executing Commands, they will not be cleaned up when the Stage ends. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. Debugging the build-magic Container If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. > build-magic --runner docker \\ --environment alpine:latest \\ --action persist \\ --command execute \"cp\" The command cp will fail because it doesn't have any arguments. The container will continue to run and can be seen with: > docker ps all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7fa0295c9d93 alpine:latest \"sh\" 36 seconds ago Up 34 seconds build-magic The container can be inspected by running a shell on the container with: > docker exec -it build-magic /bin/sh When finished, exit the container with exit . The container can then be stopped and destroyed with: > docker stop build-magic > docker rm build-magic Until the build-magic container is stopped and destroyed, build-magic won't be able to start a new container.","title":"Using the Docker Runner"},{"location":"user_guide/runners/docker_usage/#using-the-docker-command-runner","text":"The docker Command Runner executes commands in a container. Build-magic will start a new container named build-magic using the image specified by --environment . The container will start detached from the build-magic sub-process, use a pseudo TTY, and override the container entrypoint to /bin/sh . Note Build-magic only supports Linux-based containers with the docker Command Runner. Windows-based container will fail to launch.","title":"Using the Docker Command Runner"},{"location":"user_guide/runners/docker_usage/#running-shell-commands","text":"The docker Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose \\ --runner docker \\ --environment alpine:latest \\ 'echo $TERM'","title":"Running Shell Commands"},{"location":"user_guide/runners/docker_usage/#setting-the-working-directory","text":"When using the docker Command Runner, the Working Directory option --wd refers to the Working Directory within the container. Build-magic mounts a local directory, referred to as the Host Working Directory, to a Bind Directory in the container. The Bind Directory in the container might or might not be the same as the Working Directory. By default, the Host Working Directory is the current directory build-magic is executed from, but can be changed with --parameter hostwd . > build-magic -r docker -e alpine --parameter hostwd /home/myproject make The Bind Directory and Working Directory both default to /build-magic in the container. The Bind Directory can be changed with --parameter bind . > build-magic -r docker -e alpine --parameter bind /app --wd /app make Just as with every other Command Runner, the Working Directory can be changed with the --wd option.","title":"Setting the Working Directory"},{"location":"user_guide/runners/docker_usage/#copying-files-into-the-container","text":"By establishing a mount, all files in Host Working Directory are available from Bind Directory in the container. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Docker has some overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. > build-magic \\ --runner docker \\ --environment alpine:latest \\ --copy /home/myproject \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Instead of copying individual files to the Working Directory, an entire directory can be used by the container by setting the Host Working Directory, Bind Directory, and Working Directory: > build-magic \\ --runner docker \\ --environment alpine:latest \\ --parameter hostwd /home/myproject \\ --parameter bind /app \\ --wd /app \\ --command install \"apk add gcc\" \\ --command build 'make'","title":"Copying Files Into the Container"},{"location":"user_guide/runners/docker_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the Host Working Directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If the Working Directory is different from the Bind Directory, all files will be lost when the build-magic container is destroyed when build-magic exits. However, if the Working Directory is also the Bind Directory, any newly created files in the Host Working Directory will be deleted. The exception is for files that are copied to the Host Working Directory from a directory specified with the --copy option. Since these files are copied before the Stage starts executing Commands, they will not be cleaned up when the Stage ends. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/docker_usage/#debugging-the-build-magic-container","text":"If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. > build-magic --runner docker \\ --environment alpine:latest \\ --action persist \\ --command execute \"cp\" The command cp will fail because it doesn't have any arguments. The container will continue to run and can be seen with: > docker ps all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7fa0295c9d93 alpine:latest \"sh\" 36 seconds ago Up 34 seconds build-magic The container can be inspected by running a shell on the container with: > docker exec -it build-magic /bin/sh When finished, exit the container with exit . The container can then be stopped and destroyed with: > docker stop build-magic > docker rm build-magic Until the build-magic container is stopped and destroyed, build-magic won't be able to start a new container.","title":"Debugging the build-magic Container"},{"location":"user_guide/runners/local_usage/","text":"Using the Local Command Runner The local Command Runner executes commands on the host machine where build-magic is running. This means build-magic can only run commands that work on the host machine or shell where build-magic is running. Running Shell Commands The local Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' > build-magic --verbose 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose 'echo $SHELL' Setting the Working Directory The Working Directory is the path that build-magic operates from. By default, the Working Directory is the current directory of the shell when build-magic is executed. On Linux and MacOS, this directory is the value of $PWD or pwd on Windows. The Working Directory can be changed to any path the user has permission to read from with the --wd option. > build-magic --wd ~/myproject make Cleaning Up New Files Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Using the Local Runner"},{"location":"user_guide/runners/local_usage/#using-the-local-command-runner","text":"The local Command Runner executes commands on the host machine where build-magic is running. This means build-magic can only run commands that work on the host machine or shell where build-magic is running.","title":"Using the Local Command Runner"},{"location":"user_guide/runners/local_usage/#running-shell-commands","text":"The local Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' > build-magic --verbose 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose 'echo $SHELL'","title":"Running Shell Commands"},{"location":"user_guide/runners/local_usage/#setting-the-working-directory","text":"The Working Directory is the path that build-magic operates from. By default, the Working Directory is the current directory of the shell when build-magic is executed. On Linux and MacOS, this directory is the value of $PWD or pwd on Windows. The Working Directory can be changed to any path the user has permission to read from with the --wd option. > build-magic --wd ~/myproject make","title":"Setting the Working Directory"},{"location":"user_guide/runners/local_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. > build-magic --action cleanup \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/remote_usage/","text":"Using the Remote Command Runner The remote Command Runner executes commands on a remote machine. To execute commands remotely, SSH needs to be installed on the host machine and configured using a public/private key pair. This way, build-magic can execute commands without prompting the user for a password. Note To connect to or from a Windows 10 machine, OpenSSH needs to be installed on the Windows machine. Build-magic isn't compatible with other Windows SSH implementations or PuTTY .ppk files. You can find instructions on installing OpenSSH for Windows 10 here . To connect to a remote machine, the --environment option should include the user and hostname of the machine to connect to, for example: build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ \"echo hello world\" Optionally, the port can also be given. By default, the port SSH will use is 22. build-magic --verbose \\ --runner remote \\ --environment user@myhost:2222 \\ \"echo hello world\" Running Shell Commands The remote Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose --runner remote --environment user@myhost 'echo $SHELL' Setting the Working Directory The Working Directory is the path that build-magic operates from. By default, the Working Directory is the home directory of user used for logging into the remote machine. The Working Directory can be changed to any path the user has permission to read from with the --wd option. > build-magic --runner remote --environment user@myhost --wd ~/myproject make Copying Files To The Remote Machine Individual files can be copied to the remote machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. > build-magic \\ --runner remote \\ --environment user@myhost \\ --copy /home/myproject \\ --command execute ./configure \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Cleaning Up New Files Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files on the remote machine with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory on the remote machine before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. > build-magic --action cleanup \\ --runner remote \\ --environment user@myhost \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. If using the --copy option to copy files to the working directory on the remote machine, these files are deleted along with any new files created during the Stage. Working with Public/Private Keypairs The remote Command Runner uses SSH public/private keypairs to connect to remote machines and execute commands. By default, build-magic looks for the private key at ~/.ssh/id_rsa . The path to the private key can be specified with --parameter keypath : > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keypath ~/ssh/keys/id_rsa \\ --command execute 'echo hello world' Build-magic supports several different SSH key types: rsa dsa ecdsa ed25519 The SSH key type can be specified with --parameter keytype : > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --command execute 'echo hello world' To use a private key protected by a passphrase, use --parameter keypass : > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --parameter keypass secret \\ --command execute 'echo hello world'","title":"Using the Remote Runner"},{"location":"user_guide/runners/remote_usage/#using-the-remote-command-runner","text":"The remote Command Runner executes commands on a remote machine. To execute commands remotely, SSH needs to be installed on the host machine and configured using a public/private key pair. This way, build-magic can execute commands without prompting the user for a password. Note To connect to or from a Windows 10 machine, OpenSSH needs to be installed on the Windows machine. Build-magic isn't compatible with other Windows SSH implementations or PuTTY .ppk files. You can find instructions on installing OpenSSH for Windows 10 here . To connect to a remote machine, the --environment option should include the user and hostname of the machine to connect to, for example: build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ \"echo hello world\" Optionally, the port can also be given. By default, the port SSH will use is 22. build-magic --verbose \\ --runner remote \\ --environment user@myhost:2222 \\ \"echo hello world\"","title":"Using the Remote Command Runner"},{"location":"user_guide/runners/remote_usage/#running-shell-commands","text":"The remote Command Runner invokes the default shell to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ 'ps -ef | grep python' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose --runner remote --environment user@myhost 'echo $SHELL'","title":"Running Shell Commands"},{"location":"user_guide/runners/remote_usage/#setting-the-working-directory","text":"The Working Directory is the path that build-magic operates from. By default, the Working Directory is the home directory of user used for logging into the remote machine. The Working Directory can be changed to any path the user has permission to read from with the --wd option. > build-magic --runner remote --environment user@myhost --wd ~/myproject make","title":"Setting the Working Directory"},{"location":"user_guide/runners/remote_usage/#copying-files-to-the-remote-machine","text":"Individual files can be copied to the remote machine from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. > build-magic \\ --runner remote \\ --environment user@myhost \\ --copy /home/myproject \\ --command execute ./configure \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp","title":"Copying Files To The Remote Machine"},{"location":"user_guide/runners/remote_usage/#cleaning-up-new-files","text":"Compiling software into executables can often produce extra files that need to be manually deleted. Build-magic can clean up these newly created files on the remote machine with the cleanup Action. The cleanup Action will take a snapshot of every file and directory in the working directory on the remote machine before the Stage runs. At the end of the Stage, any files or directories that don't exist in the snapshot are deleted. If there are build artifacts that shouldn't be deleted, they should be moved or deployed before the Stage ends so that they aren't deleted. These build artifacts are typically binary executables, archives, or minified code and should be pushed to an artifactory, moved, or deployed before the Stage ends. The cleanup Action can be executed with the --action option. > build-magic --action cleanup \\ --runner remote \\ --environment user@myhost \\ -c build 'python setup.py sdist bdist_wheel --universal' \\ -c release 'twine upload dist/*' Note There is a special exclusion to prevent deleting files and directories that are modified inside the .git directory in the working directory to prevent git from becoming corrupted. If using the --copy option to copy files to the working directory on the remote machine, these files are deleted along with any new files created during the Stage.","title":"Cleaning Up New Files"},{"location":"user_guide/runners/remote_usage/#working-with-publicprivate-keypairs","text":"The remote Command Runner uses SSH public/private keypairs to connect to remote machines and execute commands. By default, build-magic looks for the private key at ~/.ssh/id_rsa . The path to the private key can be specified with --parameter keypath : > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keypath ~/ssh/keys/id_rsa \\ --command execute 'echo hello world' Build-magic supports several different SSH key types: rsa dsa ecdsa ed25519 The SSH key type can be specified with --parameter keytype : > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --command execute 'echo hello world' To use a private key protected by a passphrase, use --parameter keypass : > build-magic --verbose \\ --runner remote \\ --environment user@myhost \\ --parameter keytype ecdsa \\ --parameter keypath ~/.ssh/id_ecdsa \\ --parameter keypass secret \\ --command execute 'echo hello world'","title":"Working with Public/Private Keypairs"},{"location":"user_guide/runners/vagrant_usage/","text":"Using the Vagrant Command Runner The vagrant Command Runner executes commands in a virtual machine. Vagrant is a command line utility for creating and managing virtual machines. A specialized Ruby scripted called a Vagrantfile is used to provision the virtual machine. Build-magic will start a new virtual machine provisioned by a specified Vagrantfile. The path to the Vagrantfile can be provided by the --environment option. When the Stage ends, build-magic will destroy the virtual machine so that it doesn't continue to use resources on the host machine. Note Virtual machines are significantly slower to start up compared to containers. Depending on the Vagrant Box used, the VM Provider configured, and the host machine resources, the virtual machine can take 30+ seconds to start up. Note Build-magic only supports Linux-based Vagrant Boxes with the vagrant Command Runner. Using a Virtual Machine Compared to a Container There are a few noteworthy differences between using the vagrant Command Runner to execute commands in a virtual machine vs using the docker Command Runner to execute commands in a container. Virtual machines much more closely resemble a full operating system compared to a container. This can be useful when testing package installation for a target operating system/distribution/version. Containers are relatively minimal and won't have a lot of programs or libraries available by default. Virtual machines are significantly slower to start up compared to a container. Virtual machines typically consume more resources (CPU, memory, disk space) on the host machine compared to containers. Running Shell Commands The vagrant Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ 'echo $TERM' Setting the Working Directory When using the vagrant Command Runner, the Working Directory option --wd refers to the Working Directory within the virtual machine. Note The host directory and bind directory are set from the Vagrantfile with config.vm.synced_folder , and therefore cannot be controlled by build-magic. See the Vagrant Synced Folders documentation for details. Unlike the docker Command Runner, the Working Directory and Bind Directory for the vagrant Command Runner do not default to the same directory. The Working Directory defaults to /home/vagrant and the Bind Directory defaults to /vagrant . This means if you want the Working Directory to be set to the Bind Directory, the --wd option must be used to set the Working Directory to /vagrant . > build-magic -r vagrant -e . --wd /vagrant make Copying Files Into the Virtual Machine By using synced folders, all files in Host Working Directory are available from Bind Directory in the virtual machine. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Some of the synced folder implementations Vagrant uses have significant overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. > build-magic \\ --runner vagrant \\ --environment Vagrantfile \\ --copy /home/myproject \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp Debugging the Virtual Machine If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. > build-magic --runner vagrant \\ --environment Vagrantfile \\ --action persist \\ --command execute \"cp\" The command cp will fail because it doesn't have any arguments. The virtual machine will continue to run and can be accessed with: > vagrant ssh When finished, exit the virtual machine with exit . The virtual machine can then be stopped and destroyed with: > vagrant destroy","title":"Using the Vagrant Runner"},{"location":"user_guide/runners/vagrant_usage/#using-the-vagrant-command-runner","text":"The vagrant Command Runner executes commands in a virtual machine. Vagrant is a command line utility for creating and managing virtual machines. A specialized Ruby scripted called a Vagrantfile is used to provision the virtual machine. Build-magic will start a new virtual machine provisioned by a specified Vagrantfile. The path to the Vagrantfile can be provided by the --environment option. When the Stage ends, build-magic will destroy the virtual machine so that it doesn't continue to use resources on the host machine. Note Virtual machines are significantly slower to start up compared to containers. Depending on the Vagrant Box used, the VM Provider configured, and the host machine resources, the virtual machine can take 30+ seconds to start up. Note Build-magic only supports Linux-based Vagrant Boxes with the vagrant Command Runner.","title":"Using the Vagrant Command Runner"},{"location":"user_guide/runners/vagrant_usage/#using-a-virtual-machine-compared-to-a-container","text":"There are a few noteworthy differences between using the vagrant Command Runner to execute commands in a virtual machine vs using the docker Command Runner to execute commands in a container. Virtual machines much more closely resemble a full operating system compared to a container. This can be useful when testing package installation for a target operating system/distribution/version. Containers are relatively minimal and won't have a lot of programs or libraries available by default. Virtual machines are significantly slower to start up compared to a container. Virtual machines typically consume more resources (CPU, memory, disk space) on the host machine compared to containers.","title":"Using a Virtual Machine Compared to a Container"},{"location":"user_guide/runners/vagrant_usage/#running-shell-commands","text":"The vagrant Command Runner invokes /bin/sh to execute commands, allowing the use of redirection and piping. > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ -c execute 'echo \"hello world\" > hello.txt' \\ -c execute 'cat hello.txt' Environment variables can be included in commands by wrapping the command in single quotes: > build-magic --verbose \\ --runner vagrant \\ --environment Vagrantfile \\ 'echo $TERM'","title":"Running Shell Commands"},{"location":"user_guide/runners/vagrant_usage/#setting-the-working-directory","text":"When using the vagrant Command Runner, the Working Directory option --wd refers to the Working Directory within the virtual machine. Note The host directory and bind directory are set from the Vagrantfile with config.vm.synced_folder , and therefore cannot be controlled by build-magic. See the Vagrant Synced Folders documentation for details. Unlike the docker Command Runner, the Working Directory and Bind Directory for the vagrant Command Runner do not default to the same directory. The Working Directory defaults to /home/vagrant and the Bind Directory defaults to /vagrant . This means if you want the Working Directory to be set to the Bind Directory, the --wd option must be used to set the Working Directory to /vagrant . > build-magic -r vagrant -e . --wd /vagrant make","title":"Setting the Working Directory"},{"location":"user_guide/runners/vagrant_usage/#copying-files-into-the-virtual-machine","text":"By using synced folders, all files in Host Working Directory are available from Bind Directory in the virtual machine. While it's possible to work on files in the Bind Directory, it isn't recommended for I/O intensive operations like compiling code. Some of the synced folder implementations Vagrant uses have significant overhead associated with the mount, so in situations where performance is slow, it's a good idea to instead copy files from the Bind Directory to the Working Directory. Individual files can be copied into the container from a directory specified with the --copy option. If using the --copy option, the files to copy should be specified as arguments. > build-magic \\ --runner vagrant \\ --environment Vagrantfile \\ --copy /home/myproject \\ --command install \"apk add gcc\" \\ --command build 'make' \\ main.cpp plugins.cpp audio.cpp","title":"Copying Files Into the Virtual Machine"},{"location":"user_guide/runners/vagrant_usage/#debugging-the-virtual-machine","text":"If a command fails in the container for an unknown reason, the persist Action can be used for troubleshooting. The persist Action will keep the container running in the background after build-magic has exited. > build-magic --runner vagrant \\ --environment Vagrantfile \\ --action persist \\ --command execute \"cp\" The command cp will fail because it doesn't have any arguments. The virtual machine will continue to run and can be accessed with: > vagrant ssh When finished, exit the virtual machine with exit . The virtual machine can then be stopped and destroyed with: > vagrant destroy","title":"Debugging the Virtual Machine"}]}